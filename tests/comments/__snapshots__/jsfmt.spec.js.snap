// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`assignment-pattern.coffee 1`] = `
{ a ### comment ### = 1 } = b

{ c = 1 ### comment ### } = d

{a = #comment
 b} = c
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
{ a ### comment ### = 1 } = b

{ c = 1 ### comment ### } = d

{
  a = b #comment
} = c

`;

exports[`before-comma.coffee 1`] = `
foo = {
  a: 'a' ### comment for this line ###,

  ### Section B ###
  b: 'b',
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
foo =
  a: "a" ### comment for this line ###

  ### Section B ###
  b: "b"

`;

exports[`blank.coffee 1`] = `
# This file only
# has comments. This comment
# should still exist
#
# when printed.

###*
# @typedef {DataDrivenMapping|ConstantMapping} Mapping
###
###*
# @typedef {Object.<String, Mapping>} ConfigurationMapping
###

###*
# @typedef {Function} D3Scale - a D3 scale
# @property {Function} ticks
# @property {Function} tickFormat
###
# comment

# comment
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This file only
# has comments. This comment
# should still exist
#
# when printed.

###*
# @typedef {DataDrivenMapping|ConstantMapping} Mapping
###
###*
# @typedef {Object.<String, Mapping>} ConfigurationMapping
###

###*
# @typedef {Function} D3Scale - a D3 scale
# @property {Function} ticks
# @property {Function} tickFormat
###
# comment

# comment

`;

exports[`break-continue-statements.coffee 1`] = `
loop
  break ### comment ###
  continue ### comment ###
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
loop
  break ### comment ###
  continue ### comment ###

`;

exports[`call_comment.coffee 1`] = `
render( # Warm any cache
  <ChildUpdates renderAnchor={true} anchorClassOn={true} />,
  container
)

React.render( # Warm any cache
  <ChildUpdates renderAnchor={true} anchorClassOn={true} />,
  container
)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
render(
  # Warm any cache
  <ChildUpdates renderAnchor={true} anchorClassOn={true} />
  container
)

React.render(
  # Warm any cache
  <ChildUpdates renderAnchor={true} anchorClassOn={true} />
  container
)

`;

exports[`closure-compiler-type-cast.coffee 1`] = `
# test to make sure comments are attached correctly
inlineComment = ### some comment ### (
  someReallyLongFunctionCall(withLots, ofArguments))

object = {
  key: ### some comment ### (someReallyLongFunctionCall(withLots, ofArguments))
}

# preserve parens only for type casts
assignment = ###* @type {string} ### (getValue())

functionCall(1 + ###* @type {string} ### (value), ###* @type {!Foo} ### ({}))

returnValue = ->
  return ###* @type {!Array.<string>} ### (['hello', 'you'])
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# test to make sure comments are attached correctly
inlineComment = ### some comment ### someReallyLongFunctionCall(
  withLots
  ofArguments
)

object =
  key: ### some comment ### someReallyLongFunctionCall withLots, ofArguments

# preserve parens only for type casts
assignment = ###* @type {string} ### getValue()

functionCall 1 + ###* @type {string} ### value, ###* @type {!Foo} ### {}

returnValue = ->
  return ###* @type {!Array.<string>} ### ["hello", "you"]

`;

exports[`dangling.coffee 1`] = `
x = {### dangling ###}
x = {
  # dangling
}
x = [### dangling ###]
x = ->
  ### dangling ###
class Foo extends Qux
  ### dangling ###
export ### dangling ###{}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
x = {
  ### dangling ###
}
x = {
  # dangling
}
x = [
  ### dangling ###
]
x = ->
  ### dangling ###
class Foo extends Qux
### dangling ###
export ### dangling ###{}

`;

exports[`dangling_array.coffee 1`] = `
expect(() => {}).toTriggerReadyStateChanges([
  # Nothing.
])

[1 ### first comment ###, 2 ### second comment ###, 3]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
expect(=> {}).toTriggerReadyStateChanges [
  # Nothing.
]

[1 ### first comment ###, 2 ### second comment ###, 3]

`;

exports[`export.coffee 1`] = `
export ### comment ### {}

export {
  foo # comment
}

export {
  # comment
  bar
}

export {
  fooo, # comment
  barr, # comment
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
export ### comment ###{}

export {
  foo # comment
}

export {
  # comment
  bar
}

export {
  fooo # comment
  barr # comment
}

`;

exports[`first-line.coffee 1`] = `
a # comment
b
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
a # comment
b

`;

exports[`function-declaration.coffee 1`] = `
a = (### comment ###) -> # comment
b = -> # comment
c = (### comment ### argA, argB, argC) -> # comment
call((###object### row) => {})
KEYPAD_NUMBERS.map((num) => ( # Buttons 0-9
  <div />
))

f = ### f ###() ->
f = (### args ###) ->
f = () ### returns ### ->
f = ### f ###(### args ###) ### returns ### ->

f = ### f ###(### a ### a) ->
f = ### f ###(a ### a ###) ->
f = ### f ###(### a ### a) ### returns ### ->

obj = {
  f1: ### f ###() ->
  f2: (### args ###) ->
  f3: () ### returns ### ->
  f4: ### f ###(### args ###) ### returns ### ->
}

(### f ###() ->)()
((### args ###) ->)()
(() ### returns ### ->)()
(### f ###(### args ###) ### returns ### ->)()

class C
  f: ### f ###() ->
class C
  f: (### args ###) ->
class C
  f: () ### returns ### ->
class C
  f: ### f ###(### args ###) ### returns ### ->
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
a = (### comment ###) ->
  # comment
b = ->
  # comment
c = (### comment ### argA, argB, argC) ->
  # comment
call (###object### row) => {}
KEYPAD_NUMBERS.map (num) =>
  # Buttons 0-9
  <div />

f = ### f ### ->
f = (### args ###) ->
f = () ### returns ### ->
f = ### f ### (### args ###) ### returns ### ->

f = ### f ### (### a ### a) ->
f = ### f ### (a ### a ###) ->
f = ### f ### (### a ### a) ### returns ### ->

obj =
  f1: ### f ### ->
  f2: (### args ###) ->
  f3: () ### returns ### ->
  f4: ### f ### (### args ###) ### returns ### ->

### f ### (->)()
((### args ###) ->)()
(() ### returns ### ->)()
### f ### ((### args ###) ### returns ### ->)()

class C
  f: ### f ### () ->
class C
  f: (### args ###) ->
class C
  f: () ### returns ### ->
class C
  f: ### f ### (### args ###) ### returns ### ->

`;

exports[`if.coffee 1`] = `
if (1)
# comment
  false
# comment
else if (2)
  true
# multi
# ple
# lines
else if (3)
  # existing comment
  true
# okay?
else if (4)
  # empty with existing comment
# comment
else ;

if (5) # comment
  true

if (6) # comment
  true
else if (7) # comment
  true
else # comment
  true

if (8) # comment
# comment
  true
else if (9) # comment
# comment
  true
else # comment
# comment
  true

if (10) ### comment ### # comment
  true
else if (11) ### comment ###
  true
else if (12) # comment ### comment ### # comment
  true
else if (13) ### comment ### ### comment ### # comment
  true
else ### comment ###
  true

if (14) # comment
### comment ###
# comment
  true
else if (15) # comment
### comment ###
### comment ### # comment
  true
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
if 1
  # comment
  false
# comment
else if 2
  true
# multi
# ple
# lines
else if 3
  # existing comment
  true
# okay?
else if 4
  # empty with existing comment
# comment
else

if 5
  # comment
  true

if 6
  # comment
  true
else if 7
  # comment
  true
else
  # comment
  true

if 8
  # comment
  # comment
  true
else if 9
  # comment
  # comment
  true
else
  # comment
  # comment
  true

if 10
  ### comment ### # comment
  true
else if 11
  ### comment ###
  true
else if 12
  # comment ### comment ### # comment
  true
else if 13
  ### comment ### ### comment ### # comment
  true
else
  ### comment ###
  true

if 14
  # comment
  ### comment ###
  # comment
  true
else if 15
  # comment
  ### comment ###
  ### comment ### # comment
  true

`;

exports[`issues.coffee 1`] = `
# Does not need to break as it fits in 80 columns
this.call(a, ### comment ### b)

f = (
  someReallyLongArgument,
  someReallyLongArgument2,
  # Trailing comment should stay after
) ->

# Comments should either stay at the end of the line or always before, but
# not one before and one after.
throw new ProcessSystemError({
  code: acc.error.code, # Alias of errno
  originalError: acc.error, # Just in case.
})

# Missing one level of indentation because of the comment
rootEpic = (actions, store) => (
  combineEpics(...epics)(actions, store)
    # Log errors and continue.
    .catch((err, stream) =>
      getLogger().error(err)
      return stream
    )
)

# optional trailing comma gets moved all the way to the beginning
regex = new RegExp(
  '^\\\\s*' + # beginning of the line
  'name\\\\s*=\\\\s*' + # name =
  '[\\'"]' + # opening quotation mark
  escapeStringRegExp(target.name) + # target name
  '[\\'"]' + # closing quotation mark
  ',?$', # optional trailing comma
)

# The comment is moved and doesn't trigger the eslint rule anymore
import path from 'path' # eslint-disable-line nuclide-internal/prefer-nuclide-uri

# Comments disappear in-between MemberExpressions
Observable.of(process)
  # Don't complete until we say so!
  .merge(Observable.never())
  # Get the errors.
  .takeUntil(if throwOnError then errors.flatMap(Observable.throw) else errors)
  .takeUntil(exit)

# Comments disappear inside of JSX
<div>
  {### Some comment ###}
</div>

# Comments in JSX tag are placed in a non optimal way
<div
  # comment
/>

# Comments disappear in empty blocks
if (1)
  # Comment
else

# Comments trigger invalid JavaScript in-between else if
if (1)
# Comment
else

# The comment makes the line break in a weird way
result = asyncExecute('non_existing_command', ### args ### [])

# The closing paren is printed on the same line as the comment
foo({}
  # Hi
)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Does not need to break as it fits in 80 columns
this.call a, ### comment ### b

f = (
  someReallyLongArgument
  someReallyLongArgument2
  # Trailing comment should stay after
) ->

# Comments should either stay at the end of the line or always before, but
# not one before and one after.
throw new ProcessSystemError(
  code: acc.error.code # Alias of errno
  originalError: acc.error # Just in case.
)

# Missing one level of indentation because of the comment
rootEpic = (actions, store) =>
  combineEpics(...epics) actions, store
    # Log errors and continue.
    .catch (err, stream) =>
      getLogger().error err
      return stream

# optional trailing comma gets moved all the way to the beginning
regex = new RegExp(
  "^\\\\s*" + # beginning of the line
  "name\\\\s*=\\\\s*" + # name =
  "['\\"]" + # opening quotation mark
  escapeStringRegExp(target.name) + # target name
  "['\\"]" + # closing quotation mark
    ",?$" # optional trailing comma
)

# The comment is moved and doesn't trigger the eslint rule anymore
import path from "path" # eslint-disable-line nuclide-internal/prefer-nuclide-uri

# Comments disappear in-between MemberExpressions
Observable.of process
  # Don't complete until we say so!
  .merge Observable.never()
  # Get the errors.
  .takeUntil if throwOnError then errors.flatMap Observable.throw else errors
  .takeUntil exit

# Comments disappear inside of JSX
<div>{### Some comment ###}</div>

# Comments in JSX tag are placed in a non optimal way
<div
# comment
/>

# Comments disappear in empty blocks
if 1
  # Comment
else

# Comments trigger invalid JavaScript in-between else if
if 1
# Comment
else

# The comment makes the line break in a weird way
result = asyncExecute "non_existing_command", ### args ### []

# The closing paren is printed on the same line as the comment
foo {}
# Hi

`;
