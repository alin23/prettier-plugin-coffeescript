// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`booleans.coffee 1`] = `
# Boolean Literals
# ----------------

# TODO: add method invocation tests: true.toString() is "true"

test "#764 Booleans should be indexable", ->
  toString = Boolean::toString

  eq toString, true['toString']
  eq toString, false['toString']
  eq toString, yes['toString']
  eq toString, no['toString']
  eq toString, on['toString']
  eq toString, off['toString']

  eq toString, true.toString
  eq toString, false.toString
  eq toString, yes.toString
  eq toString, no.toString
  eq toString, on.toString
  eq toString, off.toString
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
test "#764 Booleans should be indexable", ->
  toString = Boolean::toString

  eq toString, true["toString"]
  eq toString, false["toString"]
  eq toString, yes["toString"]
  eq toString, no["toString"]
  eq toString, on["toString"]
  eq toString, off["toString"]

  eq toString, true.toString
  eq toString, false.toString
  eq toString, yes.toString
  eq toString, no.toString
  eq toString, on.toString
  eq toString, off.toString

`;

exports[`comprehensions.coffee 1`] = `
# Comprehensions
# --------------

# * Array Comprehensions
# * Range Comprehensions
# * Object Comprehensions
# * Implicit Destructuring Assignment
# * Comprehensions with Nonstandard Step

# TODO: refactor comprehension tests

test "Basic array comprehensions.", ->

  nums    = (n * n for n in [1, 2, 3] when n & 1)
  results = (n * 2 for n in nums)

  ok results.join(',') is '2,18'


test "Basic object comprehensions.", ->

  obj   = {one: 1, two: 2, three: 3}
  names = (prop + '!' for prop of obj)
  odds  = (prop + '!' for prop, value of obj when value & 1)

  ok names.join(' ') is "one! two! three!"
  ok odds.join(' ')  is "one! three!"


test "Basic range comprehensions.", ->

  nums = (i * 3 for i in [1..3])

  negs = (x for x in [-20..-5*2])
  negs = negs[0..2]

  result = nums.concat(negs).join(', ')

  ok result is '3, 6, 9, -20, -19, -18'


test "With range comprehensions, you can loop in steps.", ->

  results = (x for x in [0...15] by 5)
  ok results.join(' ') is '0 5 10'

  results = (x for x in [0..100] by 10)
  ok results.join(' ') is '0 10 20 30 40 50 60 70 80 90 100'


test "And can loop downwards, with a negative step.", ->

  results = (x for x in [5..1])

  ok results.join(' ') is '5 4 3 2 1'
  ok results.join(' ') is [(10-5)..(-2+3)].join(' ')

  results = (x for x in [10..1])
  ok results.join(' ') is [10..1].join(' ')

  results = (x for x in [10...0] by -2)
  ok results.join(' ') is [10, 8, 6, 4, 2].join(' ')


test "Range comprehension gymnastics.", ->

  eq "#{i for i in [5..1]}", '5,4,3,2,1'
  eq "#{i for i in [5..-5] by -5}", '5,0,-5'

  a = 6
  b = 0
  c = -2

  eq "#{i for i in [a..b]}", '6,5,4,3,2,1,0'
  eq "#{i for i in [a..b] by c}", '6,4,2,0'


test "Multiline array comprehension with filter.", ->

  evens = for num in [1, 2, 3, 4, 5, 6] when not (num & 1)
             num *= -1
             num -= 2
             num * -1
  eq evens + '', '4,6,8'


  test "The in operator still works, standalone.", ->

    ok 2 of evens


test "all isn't reserved.", ->

  all = 1


test "Ensure that the closure wrapper preserves local variables.", ->

  obj = {}

  for method in ['one', 'two', 'three'] then do (method) ->
    obj[method] = ->
      "I'm " + method

  ok obj.one()   is "I'm one"
  ok obj.two()   is "I'm two"
  ok obj.three() is "I'm three"


test "Index values at the end of a loop.", ->

  i = 0
  for i in [1..3]
    -> 'func'
    break if false
  ok i is 4


test "Ensure that local variables are closed over for range comprehensions.", ->

  funcs = for i in [1..3]
    do (i) ->
      -> -i

  eq (func() for func in funcs).join(' '), '-1 -2 -3'
  ok i is 4


test "Even when referenced in the filter.", ->

  list = ['one', 'two', 'three']

  methods = for num, i in list when num isnt 'two' and i isnt 1
    do (num, i) ->
      -> num + ' ' + i

  ok methods.length is 2
  ok methods[0]() is 'one 0'
  ok methods[1]() is 'three 2'


test "Even a convoluted one.", ->

  funcs = []

  for i in [1..3]
    do (i) ->
      x = i * 2
      ((z)->
        funcs.push -> z + ' ' + i
      )(x)

  ok (func() for func in funcs).join(', ') is '2 1, 4 2, 6 3'

  funcs = []

  results = for i in [1..3]
    do (i) ->
      z = (x * 3 for x in [1..i])
      ((a, b, c) -> [a, b, c].join(' ')).apply this, z

  ok results.join(', ') is '3  , 3 6 , 3 6 9'


test "Naked ranges are expanded into arrays.", ->

  array = [0..10]
  ok(num % 2 is 0 for num in array by 2)


test "Nested shared scopes.", ->

  foo = ->
    for i in [0..7]
      do (i) ->
        for j in [0..7]
          do (j) ->
            -> i + j

  eq foo()[3][4](), 7


test "Scoped loop pattern matching.", ->

  a = [[0], [1]]
  funcs = []

  for [v] in a
    do (v) ->
      funcs.push -> v

  eq funcs[0](), 0
  eq funcs[1](), 1


test "Nested comprehensions.", ->

  multiLiner =
    for x in [3..5]
      for y in [3..5]
        [x, y]

  singleLiner =
    (([x, y] for y in [3..5]) for x in [3..5])

  ok multiLiner.length is singleLiner.length
  ok 5 is multiLiner[2][2][1]
  ok 5 is singleLiner[2][2][1]


test "Comprehensions within parentheses.", ->

  result = null
  store = (obj) -> result = obj
  store (x * 2 for x in [3, 2, 1])

  ok result.join(' ') is '6 4 2'


test "Closure-wrapped comprehensions that refer to the 'arguments' object.", ->

  expr = ->
    result = (item * item for item in arguments)

  ok expr(2, 4, 8).join(' ') is '4 16 64'


test "Fast object comprehensions over all properties, including prototypal ones.", ->

  class Cat
    constructor: -> @name = 'Whiskers'
    breed: 'tabby'
    hair:  'cream'

  whiskers = new Cat
  own = (value for own key, value of whiskers)
  all = (value for key, value of whiskers)

  ok own.join(' ') is 'Whiskers'
  ok all.sort().join(' ') is 'Whiskers cream tabby'


test "Optimized range comprehensions.", ->

  exxes = ('x' for [0...10])
  ok exxes.join(' ') is 'x x x x x x x x x x'


test "#3671: Allow step in optimized range comprehensions.", ->

  exxes = ('x' for [0...10] by 2)
  eq exxes.join(' ') , 'x x x x x'


test "#3671: Disallow guard in optimized range comprehensions.", ->

  throws -> CoffeeScript.compile "exxes = ('x' for [0...10] when a)"


test "Loop variables should be able to reference outer variables", ->
  outer = 1
  do ->
    null for outer in [1, 2, 3]
  eq outer, 3


test "Lenient on pure statements not trying to reach out of the closure", ->

  val = for i in [1]
    for j in [] then break
    i
  ok val[0] is i


test "Comprehensions only wrap their last line in a closure, allowing other lines
  to have pure expressions in them.", ->

  func = -> for i in [1]
    break if i is 2
    j for j in [1]

  ok func()[0][0] is 1

  i = 6
  odds = while i--
    continue unless i & 1
    i

  ok odds.join(', ') is '5, 3, 1'


test "Issue #897: Ensure that plucked function variables aren't leaked.", ->

  facets = {}
  list = ['one', 'two']

  (->
    for entity in list
      facets[entity] = -> entity
  )()

  eq typeof entity, 'undefined'
  eq facets['two'](), 'two'


test "Issue #905. Soaks as the for loop subject.", ->

  a = {b: {c: [1, 2, 3]}}
  for d in a.b?.c
    e = d

  eq e, 3


test "Issue #948. Capturing loop variables.", ->

  funcs = []
  list  = ->
    [1, 2, 3]

  for y in list()
    do (y) ->
      z = y
      funcs.push -> "y is #{y} and z is #{z}"

  eq funcs[1](), "y is 2 and z is 2"


test "Cancel the comprehension if there's a jump inside the loop.", ->

  result = try
    for i in [0...10]
      continue if i < 5
    i

  eq result, 10


test "Comprehensions over break.", ->

  arrayEq (break for [1..10]), []


test "Comprehensions over continue.", ->

  arrayEq (continue for [1..10]), []


test "Comprehensions over function literals.", ->

  a = 0
  for f in [-> a = 1]
    do (f) ->
      do f

  eq a, 1


test "Comprehensions that mention arguments.", ->

  list = [arguments: 10]
  args = for f in list
    do (f) ->
      f.arguments
  eq args[0], 10


test "expression conversion under explicit returns", ->
  nonce = {}
  fn = ->
    return (nonce for x in [1,2,3])
  arrayEq [nonce,nonce,nonce], fn()
  fn = ->
    return [nonce for x in [1,2,3]][0]
  arrayEq [nonce,nonce,nonce], fn()
  fn = ->
    return [(nonce for x in [1..3])][0]
  arrayEq [nonce,nonce,nonce], fn()


test "implicit destructuring assignment in object of objects", ->
  a={}; b={}; c={}
  obj = {
    a: { d: a },
    b: { d: b }
    c: { d: c }
  }
  result = ([y,z] for y, { d: z } of obj)
  arrayEq [['a',a],['b',b],['c',c]], result


test "implicit destructuring assignment in array of objects", ->
  a={}; b={}; c={}; d={}; e={}; f={}
  arr = [
    { a: a, b: { c: b } },
    { a: c, b: { c: d } },
    { a: e, b: { c: f } }
  ]
  result = ([y,z] for { a: y, b: { c: z } } in arr)
  arrayEq [[a,b],[c,d],[e,f]], result


test "implicit destructuring assignment in array of arrays", ->
  a={}; b={}; c={}; d={}; e={}; f={}
  arr = [[a, [b]], [c, [d]], [e, [f]]]
  result = ([y,z] for [y, [z]] in arr)
  arrayEq [[a,b],[c,d],[e,f]], result

test "issue #1124: don't assign a variable in two scopes", ->
  lista = [1, 2, 3, 4, 5]
  listb = (_i + 1 for _i in lista)
  arrayEq [2, 3, 4, 5, 6], listb

test "#1326: \`by\` value is uncached", ->
  a = [0,1,2]
  fi = gi = hi = 0
  f = -> ++fi
  g = -> ++gi
  h = -> ++hi

  forCompile = []
  rangeCompileSimple = []

  #exercises For.compile
  for v, i in a by f()
    forCompile.push i

  #exercises Range.compileSimple
  rangeCompileSimple = (i for i in [0..2] by g())

  arrayEq a, forCompile
  arrayEq a, rangeCompileSimple
  #exercises Range.compile
  eq "#{i for i in [0..2] by h()}", '0,1,2'

test "#1669: break/continue should skip the result only for that branch", ->
  ns = for n in [0..99]
    if n > 9
      break
    else if n & 1
      continue
    else
      n
  eq "#{ns}", '0,2,4,6,8'

  # \`else undefined\` is implied.
  ns = for n in [1..9]
    if n % 2
      continue unless n % 5
      n
  eq "#{ns}", "1,,3,,,7,,9"

  # Ditto.
  ns = for n in [1..9]
    switch
      when n % 2
        continue unless n % 5
        n
  eq "#{ns}", "1,,3,,,7,,9"

test "#1850: inner \`for\` should not be expression-ized if \`return\`ing", ->
  eq '3,4,5', do ->
    for a in [1..9] then \\
    for b in [1..9]
      c = Math.sqrt a*a + b*b
      return String [a, b, c] unless c % 1

test "#1910: loop index should be mutable within a loop iteration and immutable between loop iterations", ->
  n = 1
  iterations = 0
  arr = [0..n]
  for v, k in arr
    ++iterations
    v = k = 5
    eq 5, k
  eq 2, k
  eq 2, iterations

  iterations = 0
  for v in [0..n]
    ++iterations
  eq 2, k
  eq 2, iterations

  arr = ([v, v + 1] for v in [0..5])
  iterations = 0
  for [v0, v1], k in arr when v0
    k += 3
    ++iterations
  eq 6, k
  eq 5, iterations

test "#2007: Return object literal from comprehension", ->
  y = for x in [1, 2]
    foo: "foo" + x
  eq 2, y.length
  eq "foo1", y[0].foo
  eq "foo2", y[1].foo

  x = 2
  y = while x
    x: --x
  eq 2, y.length
  eq 1, y[0].x
  eq 0, y[1].x

test "#2274: Allow @values as loop variables", ->
  obj = {
    item: null
    method: ->
      for @item in [1, 2, 3]
        null
  }
  eq obj.item, null
  obj.method()
  eq obj.item, 3

test "#4411: Allow @values as loop indices", ->
  obj =
    index: null
    get: -> @index
    method: ->
      @get() for _, @index in [1, 2, 3]
  eq obj.index, null
  arrayEq obj.method(), [0, 1, 2]
  eq obj.index, 3

test "#2525, #1187, #1208, #1758, looping over an array forwards", ->
  list = [0, 1, 2, 3, 4]

  ident = (x) -> x

  arrayEq (i for i in list), list

  arrayEq (index for i, index in list), list

  arrayEq (i for i in list by 1), list

  arrayEq (i for i in list by ident 1), list

  arrayEq (i for i in list by ident(1) * 2), [0, 2, 4]

  arrayEq (index for i, index in list by ident(1) * 2), [0, 2, 4]

test "#2525, #1187, #1208, #1758, looping over an array backwards", ->
  list = [0, 1, 2, 3, 4]
  backwards = [4, 3, 2, 1, 0]

  ident = (x) -> x

  arrayEq (i for i in list by -1), backwards

  arrayEq (index for i, index in list by -1), backwards

  arrayEq (i for i in list by ident -1), backwards

  arrayEq (i for i in list by ident(-1) * 2), [4, 2, 0]

  arrayEq (index for i, index in list by ident(-1) * 2), [4, 2, 0]

test "splats in destructuring in comprehensions", ->
  list = [[0, 1, 2], [2, 3, 4], [4, 5, 6]]
  arrayEq (seq for [rep, seq...] in list), [[1, 2], [3, 4], [5, 6]]

test "#156: expansion in destructuring in comprehensions", ->
  list = [[0, 1, 2], [2, 3, 4], [4, 5, 6]]
  arrayEq (last for [..., last] in list), [2, 4, 6]

test "#3778: Consistently always cache for loop range boundaries and steps, even
      if they are simple identifiers", ->
  a = 1; arrayEq [1, 2, 3], (for n in [1, 2, 3] by  a then a = 4; n)
  a = 1; arrayEq [1, 2, 3], (for n in [1, 2, 3] by +a then a = 4; n)
  a = 1; arrayEq [1, 2, 3], (for n in [a..3]          then a = 4; n)
  a = 1; arrayEq [1, 2, 3], (for n in [+a..3]         then a = 4; n)
  a = 3; arrayEq [1, 2, 3], (for n in [1..a]          then a = 4; n)
  a = 3; arrayEq [1, 2, 3], (for n in [1..+a]         then a = 4; n)
  a = 1; arrayEq [1, 2, 3], (for n in [1..3] by  a    then a = 4; n)
  a = 1; arrayEq [1, 2, 3], (for n in [1..3] by +a    then a = 4; n)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
test "Basic array comprehensions.", ->
  nums = (n * n for n in [1, 2, 3] when n & 1)
  results = (n * 2 for n in nums)

  ok results.join(",") is "2,18"

test "Basic object comprehensions.", ->
  obj = one: 1, two: 2, three: 3
  names = (prop + "!" for prop of obj)
  odds = (prop + "!" for prop, value of obj when value & 1)

  ok names.join(" ") is "one! two! three!"
  ok odds.join(" ") is "one! three!"

test "Basic range comprehensions.", ->
  nums = (i * 3 for i in [1..3])

  negs = (x for x in [-20..(-5 * 2)])
  negs = negs[0..2]

  result = nums.concat(negs).join ", "

  ok result is "3, 6, 9, -20, -19, -18"

test "With range comprehensions, you can loop in steps.", ->
  results = (x for x in [0...15] by 5)
  ok results.join(" ") is "0 5 10"

  results = (x for x in [0..100] by 10)
  ok results.join(" ") is "0 10 20 30 40 50 60 70 80 90 100"

test "And can loop downwards, with a negative step.", ->
  results = (x for x in [5..1])

  ok results.join(" ") is "5 4 3 2 1"
  ok results.join(" ") is [(10 - 5)..(-2 + 3)].join " "

  results = (x for x in [10..1])
  ok results.join(" ") is [10..1].join " "

  results = (x for x in [10...0] by -2)
  ok results.join(" ") is [10, 8, 6, 4, 2].join " "

test "Range comprehension gymnastics.", ->
  eq "#{i for i in [5..1]}", "5,4,3,2,1"
  eq "#{i for i in [5..-5] by -5}", "5,0,-5"

  a = 6
  b = 0
  c = -2

  eq "#{i for i in [a..b]}", "6,5,4,3,2,1,0"
  eq "#{i for i in [a..b] by c}", "6,4,2,0"

test "Multiline array comprehension with filter.", ->
  evens =
    for num in [1, 2, 3, 4, 5, 6] when not (num & 1)
      num *= -1
      num -= 2
      num * -1
  eq evens + "", "4,6,8"

  test "The in operator still works, standalone.", -> ok 2 of evens

test "all isn't reserved.", -> all = 1

test "Ensure that the closure wrapper preserves local variables.", ->
  obj = {}

  for method in ["one", "two", "three"] then do (method) ->
    obj[method] = -> "I'm " + method

  ok obj.one() is "I'm one"
  ok obj.two() is "I'm two"
  ok obj.three() is "I'm three"

test "Index values at the end of a loop.", ->
  i = 0
  for i in [1..3]
    -> "func"
    break if false
  ok i is 4

test "Ensure that local variables are closed over for range comprehensions.", ->
  funcs =
    for i in [1..3] then do (i) ->
      -> -i

  eq (func() for func in funcs).join(" "), "-1 -2 -3"
  ok i is 4

test "Even when referenced in the filter.", ->
  list = ["one", "two", "three"]

  methods =
    for num, i in list when num isnt "two" and i isnt 1 then do (num, i) ->
      -> num + " " + i

  ok methods.length is 2
  ok methods[0]() is "one 0"
  ok methods[1]() is "three 2"

test "Even a convoluted one.", ->
  funcs = []

  for i in [1..3] then do (i) ->
    x = i * 2
    ((z) -> funcs.push -> z + " " + i) x

  ok (func() for func in funcs).join(", ") is "2 1, 4 2, 6 3"

  funcs = []

  results =
    for i in [1..3] then do (i) ->
      z = (x * 3 for x in [1..i])
      ((a, b, c) -> [a, b, c].join " ").apply @, z

  ok results.join(", ") is "3  , 3 6 , 3 6 9"

test "Naked ranges are expanded into arrays.", ->
  array = [0..10]
  ok (num % 2 is 0 for num in array by 2)

test "Nested shared scopes.", ->
  foo = ->
    for i in [0..7] then do (i) ->
      for j in [0..7] then do (j) ->
        -> i + j

  eq foo()[3][4](), 7

test "Scoped loop pattern matching.", ->
  a = [[0], [1]]
  funcs = []

  for [v] in a then do (v) ->
    funcs.push -> v

  eq funcs[0](), 0
  eq funcs[1](), 1

test "Nested comprehensions.", ->
  multiLiner =
    for x in [3..5]
      for y in [3..5]
        [x, y]

  singleLiner = ([x, y] for y in [3..5] for x in [3..5])

  ok multiLiner.length is singleLiner.length
  ok 5 is multiLiner[2][2][1]
  ok 5 is singleLiner[2][2][1]

test "Comprehensions within parentheses.", ->
  result = null
  store = (obj) -> result = obj
  store (x * 2 for x in [3, 2, 1])

  ok result.join(" ") is "6 4 2"

test "Closure-wrapped comprehensions that refer to the 'arguments' object.", ->
  expr = -> result = (item * item for item in arguments)

  ok expr(2, 4, 8).join(" ") is "4 16 64"

test "Fast object comprehensions over all properties, including prototypal ones.", ->
  class Cat
    constructor: ->
      @name = "Whiskers"
    breed: "tabby"
    hair: "cream"

  whiskers = new Cat()
  own = (value for own key, value of whiskers)
  all = (value for key, value of whiskers)

  ok own.join(" ") is "Whiskers"
  ok all.sort().join(" ") is "Whiskers cream tabby"

test "Optimized range comprehensions.", ->
  exxes = ("x" for [0...10])
  ok exxes.join(" ") is "x x x x x x x x x x"

test "#3671: Allow step in optimized range comprehensions.", ->
  exxes = ("x" for [0...10] by 2)
  eq exxes.join(" "), "x x x x x"

test "#3671: Disallow guard in optimized range comprehensions.", ->
  throws -> CoffeeScript.compile "exxes = ('x' for [0...10] when a)"

test "Loop variables should be able to reference outer variables", ->
  outer = 1
  do ->
    null for outer in [1, 2, 3]
  eq outer, 3

test "Lenient on pure statements not trying to reach out of the closure", ->
  val =
    for i in [1]
      for j in []
        break
      i
  ok val[0] is i

test(
  "Comprehensions only wrap their last line in a closure, allowing other lines
  to have pure expressions in them."
  ->
    func = ->
      for i in [1]
        break if i is 2
        j for j in [1]

    ok func()[0][0] is 1

    i = 6
    odds =
      while i--
        continue unless i & 1
        i

    ok odds.join(", ") is "5, 3, 1"
)

test "Issue #897: Ensure that plucked function variables aren't leaked.", ->
  facets = {}
  list = ["one", "two"]

  (->
    for entity in list
      facets[entity] = -> entity
  )()

  eq typeof entity, "undefined"
  eq facets["two"](), "two"

test "Issue #905. Soaks as the for loop subject.", ->
  a = b: c: [1, 2, 3]
  for d in a.b?.c
    e = d

  eq e, 3

test "Issue #948. Capturing loop variables.", ->
  funcs = []
  list = -> [1, 2, 3]

  for y in list() then do (y) ->
    z = y
    funcs.push -> "y is #{y} and z is #{z}"

  eq funcs[1](), "y is 2 and z is 2"

test "Cancel the comprehension if there's a jump inside the loop.", ->
  result =
    try
      for i in [0...10]
        continue if i < 5
      i

  eq result, 10

test "Comprehensions over break.", -> arrayEq (break for [1..10]), []

test "Comprehensions over continue.", -> arrayEq (continue for [1..10]), []

test "Comprehensions over function literals.", ->
  a = 0
  for f in [-> a = 1] then do (f) ->
    do f

  eq a, 1

test "Comprehensions that mention arguments.", ->
  list = [arguments: 10]
  args =
    for f in list then do (f) ->
      f.arguments
  eq args[0], 10

test "expression conversion under explicit returns", ->
  nonce = {}
  fn = -> return (nonce for x in [1, 2, 3])
  arrayEq [nonce, nonce, nonce], fn()
  fn = -> return [nonce for x in [1, 2, 3]][0]
  arrayEq [nonce, nonce, nonce], fn()
  fn = -> return [nonce for x in [1..3]][0]
  arrayEq [nonce, nonce, nonce], fn()

test "implicit destructuring assignment in object of objects", ->
  a = {}
  b = {}
  c = {}
  obj =
    a: d: a
    b: d: b
    c: d: c
  result = ([y, z] for y, { d: z } of obj)
  arrayEq [["a", a], ["b", b], ["c", c]], result

test "implicit destructuring assignment in array of objects", ->
  a = {}
  b = {}
  c = {}
  d = {}
  e = {}
  f = {}
  arr = [
    a: a
    b: c: b
  ,
    a: c
    b: c: d
  ,
    a: e
    b: c: f
  ]
  result = ([y, z] for { a: y, b: { c: z } } in arr)
  arrayEq [[a, b], [c, d], [e, f]], result

test "implicit destructuring assignment in array of arrays", ->
  a = {}
  b = {}
  c = {}
  d = {}
  e = {}
  f = {}
  arr = [[a, [b]], [c, [d]], [e, [f]]]
  result = ([y, z] for [y, [z]] in arr)
  arrayEq [[a, b], [c, d], [e, f]], result

test "issue #1124: don't assign a variable in two scopes", ->
  lista = [1, 2, 3, 4, 5]
  listb = (_i + 1 for _i in lista)
  arrayEq [2, 3, 4, 5, 6], listb

test "#1326: \`by\` value is uncached", ->
  a = [0, 1, 2]
  fi = gi = hi = 0
  f = -> ++fi
  g = -> ++gi
  h = -> ++hi

  forCompile = []
  rangeCompileSimple = []

  for v, i in a by f()
    forCompile.push i

  rangeCompileSimple = (i for i in [0..2] by g())

  arrayEq a, forCompile
  arrayEq a, rangeCompileSimple
  eq "#{i for i in [0..2] by h()}", "0,1,2"

test "#1669: break/continue should skip the result only for that branch", ->
  ns =
    for n in [0..99]
      if n > 9
        break
      else if n & 1
        continue
      else
        n
  eq "#{ns}", "0,2,4,6,8"

  ns =
    for n in [1..9]
      if n % 2
        continue unless n % 5
        n
  eq "#{ns}", "1,,3,,,7,,9"

  ns =
    for n in [1..9]
      switch
        when n % 2
          continue unless n % 5
          n
  eq "#{ns}", "1,,3,,,7,,9"

test "#1850: inner \`for\` should not be expression-ized if \`return\`ing", ->
  eq(
    "3,4,5"
    do ->
      for a in [1..9]
        for b in [1..9]
          c = Math.sqrt a * a + b * b
          return String([a, b, c]) unless c % 1
  )

test "#1910: loop index should be mutable within a loop iteration and immutable between loop iterations", ->
  n = 1
  iterations = 0
  arr = [0..n]
  for v, k in arr
    ++iterations
    v = k = 5
    eq 5, k
  eq 2, k
  eq 2, iterations

  iterations = 0
  for v in [0..n]
    ++iterations
  eq 2, k
  eq 2, iterations

  arr = ([v, v + 1] for v in [0..5])
  iterations = 0
  for [v0, v1], k in arr when v0
    k += 3
    ++iterations
  eq 6, k
  eq 5, iterations

test "#2007: Return object literal from comprehension", ->
  y =
    for x in [1, 2]
      foo: "foo" + x
  eq 2, y.length
  eq "foo1", y[0].foo
  eq "foo2", y[1].foo

  x = 2
  y =
    while x
      x: --x
  eq 2, y.length
  eq 1, y[0].x
  eq 0, y[1].x

test "#2274: Allow @values as loop variables", ->
  obj =
    item: null
    method: ->
      for @item in [1, 2, 3]
        null
  eq obj.item, null
  obj.method()
  eq obj.item, 3

test "#4411: Allow @values as loop indices", ->
  obj =
    index: null, get: -> @index, method: -> @get() for _, @index in [1, 2, 3]
  eq obj.index, null
  arrayEq obj.method(), [0, 1, 2]
  eq obj.index, 3

test "#2525, #1187, #1208, #1758, looping over an array forwards", ->
  list = [0, 1, 2, 3, 4]

  ident = (x) -> x

  arrayEq (i for i in list), list

  arrayEq (index for i, index in list), list

  arrayEq (i for i in list by 1), list

  arrayEq (i for i in list by ident(1)), list

  arrayEq (i for i in list by ident(1) * 2), [0, 2, 4]

  arrayEq (index for i, index in list by ident(1) * 2), [0, 2, 4]

test "#2525, #1187, #1208, #1758, looping over an array backwards", ->
  list = [0, 1, 2, 3, 4]
  backwards = [4, 3, 2, 1, 0]

  ident = (x) -> x

  arrayEq (i for i in list by -1), backwards

  arrayEq (index for i, index in list by -1), backwards

  arrayEq (i for i in list by ident(-1)), backwards

  arrayEq (i for i in list by ident(-1) * 2), [4, 2, 0]

  arrayEq (index for i, index in list by ident(-1) * 2), [4, 2, 0]

test "splats in destructuring in comprehensions", ->
  list = [[0, 1, 2], [2, 3, 4], [4, 5, 6]]
  arrayEq (seq for [rep, seq...] in list), [[1, 2], [3, 4], [5, 6]]

test "#156: expansion in destructuring in comprehensions", ->
  list = [[0, 1, 2], [2, 3, 4], [4, 5, 6]]
  arrayEq (last for [..., last] in list), [2, 4, 6]

test(
  "#3778: Consistently always cache for loop range boundaries and steps, even
      if they are simple identifiers"
  ->
    a = 1
    arrayEq(
      [1, 2, 3]
      for n in [1, 2, 3] by a
        a = 4
        n
    )
    a = 1
    arrayEq(
      [1, 2, 3]
      for n in [1, 2, 3] by +a
        a = 4
        n
    )
    a = 1
    arrayEq(
      [1, 2, 3]
      for n in [a..3]
        a = 4
        n
    )
    a = 1
    arrayEq(
      [1, 2, 3]
      for n in [+a..3]
        a = 4
        n
    )
    a = 3
    arrayEq(
      [1, 2, 3]
      for n in [1..a]
        a = 4
        n
    )
    a = 3
    arrayEq(
      [1, 2, 3]
      for n in [1..+a]
        a = 4
        n
    )
    a = 1
    arrayEq(
      [1, 2, 3]
      for n in [1..3] by a
        a = 4
        n
    )
    a = 1
    arrayEq(
      [1, 2, 3]
      for n in [1..3] by +a
        a = 4
        n
    )
)

`;

exports[`control_flow.coffee 1`] = `
# Control Flow
# ------------

# * Conditionals
# * Loops
#   * For
#   * While
#   * Until
#   * Loop
# * Switch
# * Throw

# TODO: make sure postfix forms and expression coercion are properly tested

# shared identity function
id = (_) -> if arguments.length is 1 then _ else Array::slice.call(arguments)

# Conditionals

test "basic conditionals", ->
  if false
    ok false
  else if false
    ok false
  else
    ok true

  if true
    ok true
  else if true
    ok false
  else
    ok true

  unless true
    ok false
  else unless true
    ok false
  else
    ok true

  unless false
    ok true
  else unless false
    ok false
  else
    ok true

test "single-line conditional", ->
  if false then ok false else ok true
  unless false then ok true else ok false

test "nested conditionals", ->
  nonce = {}
  eq nonce, (if true
    unless false
      if false then false else
        if true
          nonce)

test "nested single-line conditionals", ->
  nonce = {}

  a = if false then undefined else b = if 0 then undefined else nonce
  eq nonce, a
  eq nonce, b

  c = if false then undefined else (if 0 then undefined else nonce)
  eq nonce, c

  d = if true then id(if false then undefined else nonce)
  eq nonce, d

test "empty conditional bodies", ->
  eq undefined, (if false
  else if false
  else)

test "conditional bodies containing only comments", ->
  eq undefined, (if true
    ###
    block comment
    ###
  else
    # comment
  )

  eq undefined, (if false
    # comment
  else if true
    ###
    block comment
    ###
  else)

test "return value of if-else is from the proper body", ->
  nonce = {}
  eq nonce, if false then undefined else nonce

test "return value of unless-else is from the proper body", ->
  nonce = {}
  eq nonce, unless true then undefined else nonce

test "assign inside the condition of a conditional statement", ->
  nonce = {}
  if a = nonce then 1
  eq nonce, a
  1 if b = nonce
  eq nonce, b


# Interactions With Functions

test "single-line function definition with single-line conditional", ->
  fn = -> if 1 < 0.5 then 1 else -1
  ok fn() is -1

test "function resturns conditional value with no \`else\`", ->
  fn = ->
    return if false then true
  eq undefined, fn()

test "function returns a conditional value", ->
  a = {}
  fnA = ->
    return if false then undefined else a
  eq a, fnA()

  b = {}
  fnB = ->
    return unless false then b else undefined
  eq b, fnB()

test "passing a conditional value to a function", ->
  nonce = {}
  eq nonce, id if false then undefined else nonce

test "unmatched \`then\` should catch implicit calls", ->
  a = 0
  trueFn = -> true
  if trueFn undefined then a++
  eq 1, a


# if-to-ternary

test "if-to-ternary with instanceof requires parentheses", ->
  nonce = {}
  eq nonce, (if {} instanceof Object
    nonce
  else
    undefined)

test "if-to-ternary as part of a larger operation requires parentheses", ->
  ok 2, 1 + if false then 0 else 1


# Odd Formatting

test "if-else indented within an assignment", ->
  nonce = {}
  result =
    if false
      undefined
    else
      nonce
  eq nonce, result

test "suppressed indentation via assignment", ->
  nonce = {}
  result =
    if      false then undefined
    else if no    then undefined
    else if 0     then undefined
    else if 1 < 0 then undefined
    else               id(
         if false then undefined
         else          nonce
    )
  eq nonce, result

test "tight formatting with leading \`then\`", ->
  nonce = {}
  eq nonce,
  if true
  then nonce
  else undefined

test "#738: inline function defintion", ->
  nonce = {}
  fn = if true then -> nonce
  eq nonce, fn()

test "#748: trailing reserved identifiers", ->
  nonce = {}
  obj = delete: true
  result = if obj.delete
    nonce
  eq nonce, result

test 'if-else within an assignment, condition parenthesized', ->
  result = if (1 is 1) then 'correct'
  eq result, 'correct'

  result = if ('whatever' ? no) then 'correct'
  eq result, 'correct'

  f = -> 'wrong'
  result = if (f?()) then 'correct' else 'wrong'
  eq result, 'correct'

# Postfix

test "#3056: multiple postfix conditionals", ->
  temp = 'initial'
  temp = 'ignored' unless true if false
  eq temp, 'initial'

# Loops

test "basic \`while\` loops", ->

  i = 5
  list = while i -= 1
    i * 2
  ok list.join(' ') is "8 6 4 2"

  i = 5
  list = (i * 3 while i -= 1)
  ok list.join(' ') is "12 9 6 3"

  i = 5
  func   = (num) -> i -= num
  assert = -> ok i < 5 > 0
  results = while func 1
    assert()
    i
  ok results.join(' ') is '4 3 2 1'

  i = 10
  results = while i -= 1 when i % 2 is 0
    i * 2
  ok results.join(' ') is '16 12 8 4'


test "Issue 759: \`if\` within \`while\` condition", ->

  2 while if 1 then 0


test "assignment inside the condition of a \`while\` loop", ->

  nonce = {}
  count = 1
  a = nonce while count--
  eq nonce, a
  count = 1
  while count--
    b = nonce
  eq nonce, b


test "While over break.", ->

  i = 0
  result = while i < 10
    i++
    break
  arrayEq result, []


test "While over continue.", ->

  i = 0
  result = while i < 10
    i++
    continue
  arrayEq result, []


test "Basic \`until\`", ->

  value = false
  i = 0
  results = until value
    value = true if i is 5
    i++
  ok i is 6


test "Basic \`loop\`", ->

  i = 5
  list = []
  loop
    i -= 1
    break if i is 0
    list.push i * 2
  ok list.join(' ') is '8 6 4 2'


test "break at the top level", ->
  for i in [1,2,3]
    result = i
    if i == 2
      break
  eq 2, result

test "break *not* at the top level", ->
  someFunc = ->
    i = 0
    while ++i < 3
      result = i
      break if i > 1
    result
  eq 2, someFunc()

# Switch

test "basic \`switch\`", ->

  num = 10
  result = switch num
    when 5 then false
    when 'a'
      true
      true
      false
    when 10 then true


    # Mid-switch comment with whitespace
    # and multi line
    when 11 then false
    else false

  ok result


  func = (num) ->
    switch num
      when 2, 4, 6
        true
      when 1, 3, 5
        false

  ok func(2)
  ok func(6)
  ok !func(3)
  eq func(8), undefined


test "Ensure that trailing switch elses don't get rewritten.", ->

  result = false
  switch "word"
    when "one thing"
      doSomething()
    else
      result = true unless false

  ok result

  result = false
  switch "word"
    when "one thing"
      doSomething()
    when "other thing"
      doSomething()
    else
      result = true unless false

  ok result


test "Should be able to handle switches sans-condition.", ->

  result = switch
    when null                     then 0
    when !1                       then 1
    when '' not of {''}           then 2
    when [] not instanceof Array  then 3
    when true is false            then 4
    when 'x' < 'y' > 'z'          then 5
    when 'a' in ['b', 'c']        then 6
    when 'd' in (['e', 'f'])      then 7
    else ok

  eq result, ok


test "Should be able to use \`@properties\` within the switch clause.", ->

  obj = {
    num: 101
    func: ->
      switch @num
        when 101 then '101!'
        else 'other'
  }

  ok obj.func() is '101!'


test "Should be able to use \`@properties\` within the switch cases.", ->

  obj = {
    num: 101
    func: (yesOrNo) ->
      result = switch yesOrNo
        when yes then @num
        else 'other'
      result
  }

  ok obj.func(yes) is 101


test "Switch with break as the return value of a loop.", ->

  i = 10
  results = while i > 0
    i--
    switch i % 2
      when 1 then i
      when 0 then break

  eq results.join(', '), '9, 7, 5, 3, 1'


test "Issue #997. Switch doesn't fallthrough.", ->

  val = 1
  switch true
    when true
      if false
        return 5
    else
      val = 2

  eq val, 1

# Throw

test "Throw should be usable as an expression.", ->
  try
    false or throw 'up'
    throw new Error 'failed'
  catch e
    ok e is 'up'


test "#2555, strange function if bodies", ->
  success = -> ok true
  failure = -> ok false

  success() if do ->
    yes

  failure() if try
    false

test "#1057: \`catch\` or \`finally\` in single-line functions", ->
  ok do -> try throw 'up' catch then yes
  ok do -> try yes finally 'nothing'

test "#2367: super in for-loop", ->
  class Foo
    sum: 0
    add: (val) -> @sum += val

  class Bar extends Foo
    add: (vals...) ->
      super val for val in vals
      @sum

  eq 10, (new Bar).add 2, 3, 5

test "#4267: lots of for-loops in the same scope", ->
  # This used to include the invalid JavaScript \`var do = 0\`.
  code = """
    do ->
      #{Array(200).join('for [0..0] then\\n  ')}
      true
  """
  ok CoffeeScript.eval(code)

# Test for issue #2342: Lexer: Inline \`else\` binds to wrong \`if\`/\`switch\`
test "#2343: if / then / if / then / else", ->
  a = b = yes
  c = e = g = no
  d = 1
  f = 2
  h = 3
  i = 4

  s = ->
    if a
      if b
        if c
          d
        else
          if e
            f
          else
            if g
              h
            else
              i

  t = ->
    if a then if b
      if c then d
      else if e
        f
      else if g
        h
      else
        i

  u = ->
    if a then if b
      if c then d else if e
        f
      else if g
        h
      else i

  v = ->
    if a then if b
      if c then d else if e then f
      else if g then h
      else i

  w = ->
    if a then if b
      if c then d
      else if e
          f
        else
          if g then h
          else i

  x = -> if a then if b then if c then d else if e then f else if g then h else i

  y = -> if a then if b then (if c then d else (if e then f else (if g then h else i)))

  eq 4, s()
  eq 4, t()
  eq 4, u()
  eq 4, v()
  eq 4, w()
  eq 4, x()
  eq 4, y()

  c = yes
  eq 1, s()
  eq 1, t()
  eq 1, u()
  eq 1, v()
  eq 1, w()
  eq 1, x()
  eq 1, y()

  b = no
  eq undefined, s()
  eq undefined, t()
  eq undefined, u()
  eq undefined, v()
  eq undefined, w()
  eq undefined, x()
  eq undefined, y()

test "#2343: if / then / if / then / else / else", ->
  a = b = yes
  c = e = g = no
  d = 1
  f = 2
  h = 3
  i = 4
  j = 5
  k = 6

  s = ->
    if a
      if b
        if c
          d
        else
          e
          if e
            f
          else
            if g
              h
            else
              i
      else
        j
    else
      k

  t = ->
    if a
      if b
        if c then d
        else if e
          f
        else if g
          h
        else
          i
      else
        j
    else
      k

  u = ->
    if a
      if b
        if c then d else if e
          f
        else if g
          h
        else i
      else j
    else k

  v = ->
    if a
      if b
        if c then d else if e then f
        else if g then h
        else i
      else j else k

  w = ->
    if a then if b
        if c then d
        else if e
            f
          else
            if g then h
            else i
    else j else k

  x = -> if a then if b then if c then d else if e then f else if g then h else i else j else k

  y = -> if a then (if b then (if c then d else (if e then f else (if g then h else i))) else j) else k

  eq 4, s()
  eq 4, t()
  eq 4, u()
  eq 4, v()
  eq 4, w()
  eq 4, x()
  eq 4, y()

  c = yes
  eq 1, s()
  eq 1, t()
  eq 1, u()
  eq 1, v()
  eq 1, w()
  eq 1, x()
  eq 1, y()

  b = no
  eq 5, s()
  eq 5, t()
  eq 5, u()
  eq 5, v()
  eq 5, w()
  eq 5, x()
  eq 5, y()

  a = no
  eq 6, s()
  eq 6, t()
  eq 6, u()
  eq 6, v()
  eq 6, w()
  eq 6, x()
  eq 6, y()


test "#2343: switch / when / then / if / then / else", ->
  a = b = yes
  c = e = g = no
  d = 1
  f = 2
  h = 3
  i = 4

  s = ->
    switch
      when a
        if b
          if c
            d
          else
            if e
              f
            else
              if g
                h
              else
                i


  t = ->
    switch
      when a then if b
        if c then d
        else if e
          f
        else if g
          h
        else
          i

  u = ->
    switch
      when a then if b then if c then d
      else if e then f
      else if g then h else i

  v = ->
    switch
      when a then if b then if c then d else if e then f
      else if g then h else i

  w = ->
    switch
      when a then if b then if c then d else if e then f
      else if g
        h
      else i

  x = ->
    switch
     when a then if b then if c then d else if e then f else if g then h else i

  y = -> switch
    when a then if b then (if c then d else (if e then f else (if g then h else i)))

  eq 4, s()
  eq 4, t()
  eq 4, u()
  eq 4, v()
  eq 4, w()
  eq 4, x()
  eq 4, y()

  c = yes
  eq 1, s()
  eq 1, t()
  eq 1, u()
  eq 1, v()
  eq 1, w()
  eq 1, x()
  eq 1, y()

  b = no
  eq undefined, s()
  eq undefined, t()
  eq undefined, u()
  eq undefined, v()
  eq undefined, w()
  eq undefined, x()
  eq undefined, y()

test "#2343: switch / when / then / if / then / else / else", ->
  a = b = yes
  c = e = g = no
  d = 1
  f = 2
  h = 3
  i = 4

  s = ->
    switch
      when a
        if b
          if c
            d
          else if e
            f
          else if g
            h
          else
            i
      else
        0

  t = ->
    switch
      when a
        if b
          if c then d
          else if e
            f
          else if g
            h
          else i
      else 0

  u = ->
    switch
      when a
        if b then if c
            d
          else if e
            f
          else if g
            h
          else i
      else 0

  v = ->
    switch
      when a
        if b then if c then d
        else if e
          f
        else if g
          h
        else i
      else 0

  w = ->
    switch
      when a
        if b then if c then d
        else if e then f
        else if g then h
        else i
      else 0

  x = ->
    switch
     when a
       if b then if c then d else if e then f else if g then h else i
     else 0

  y = -> switch
    when a
      if b then (if c then d else (if e then f else (if g then h else i)))
    else 0

  eq 4, s()
  eq 4, t()
  eq 4, u()
  eq 4, v()
  eq 4, w()
  eq 4, x()
  eq 4, y()

  c = yes
  eq 1, s()
  eq 1, t()
  eq 1, u()
  eq 1, v()
  eq 1, w()
  eq 1, x()
  eq 1, y()

  b = no
  eq undefined, s()
  eq undefined, t()
  eq undefined, u()
  eq undefined, v()
  eq undefined, w()
  eq undefined, x()
  eq undefined, y()

  b = yes
  a = no
  eq 0, s()
  eq 0, t()
  eq 0, u()
  eq 0, v()
  eq 0, w()
  eq 0, x()
  eq 0, y()

test "#2343: switch / when / then / if / then / else / else / else", ->
  a = b = yes
  c = e = g = no
  d = 1
  f = 2
  h = 3
  i = 4
  j = 5

  s = ->
    switch
      when a
        if b
          if c
            d
          else if e
            f
          else if g
            h
          else
            i
        else
          j
      else
        0

  t = ->
    switch
      when a
        if b
          if c then d
          else if e
            f
          else if g
            h
          else i
        else
          j
      else 0

  u = ->
    switch
      when a
        if b
          if c
            d
          else if e
            f
          else if g
            h
          else i
        else j
      else 0

  v = ->
    switch
      when a
        if b
          if c then d
          else if e
            f
          else if g then h
          else i
        else j
      else 0

  w = ->
    switch
      when a
        if b
          if c then d
          else if e then f
          else if g then h
          else i
        else j
      else 0

  x = ->
    switch
     when a
       if b then if c then d else if e then f else if g then h else i else j
     else 0

  y = -> switch
    when a
      if b then (if c then d else (if e then f else (if g then h else i))) else j
    else 0

  eq 4, s()
  eq 4, t()
  eq 4, u()
  eq 4, v()
  eq 4, w()
  eq 4, x()
  eq 4, y()

  c = yes
  eq 1, s()
  eq 1, t()
  eq 1, u()
  eq 1, v()
  eq 1, w()
  eq 1, x()
  eq 1, y()

  b = no
  eq 5, s()
  eq 5, t()
  eq 5, u()
  eq 5, v()
  eq 5, w()
  eq 5, x()
  eq 5, y()

  b = yes
  a = no
  eq 0, s()
  eq 0, t()
  eq 0, u()
  eq 0, v()
  eq 0, w()
  eq 0, x()
  eq 0, y()

# Test for issue #3921: Inline function without parentheses used in condition fails to compile
test "#3921: \`if\` & \`unless\`", ->
  a = {}
  eq a, if do -> no then undefined else a
  a1 = undefined
  if do -> yes
    a1 = a
  eq a, a1

  b = {}
  eq b, unless do -> no then b else undefined
  b1 = undefined
  unless do -> no
    b1 = b
  eq b, b1

  c = 0
  if (arg = undefined) -> yes then c++
  eq 1, c
  d = 0
  if (arg = undefined) -> yes
    d++
  eq 1, d

  answer = 'correct'
  eq answer, if do -> 'wrong' then 'correct' else 'wrong'
  eq answer, unless do -> no then 'correct' else 'wrong'
  statm1 = undefined
  if do -> 'wrong'
    statm1 = 'correct'
  eq answer, statm1
  statm2 = undefined
  unless do -> no
    statm2 = 'correct'
  eq answer, statm2

test "#3921: \`post if\`", ->
  a = {}
  eq a, a unless do -> no
  a1 = a if do -> yes
  eq a, a1

  c = 0
  c++ if (arg = undefined) -> yes
  eq 1, c
  d = 0
  d++ if (arg = undefined) -> yes
  eq 1, d

  answer = 'correct'
  eq answer, 'correct' if do -> 'wrong'
  eq answer, 'correct' unless do -> not 'wrong'
  statm1 = undefined
  statm1 = 'correct' if do -> 'wrong'
  eq answer, statm1
  statm2 = undefined
  statm2 = 'correct' unless do -> not 'wrong'
  eq answer, statm2

test "Issue 3921: \`while\` & \`until\`", ->
  i = 5
  assert = (a) -> ok 5 > a > 0
  result1 = while do (num = 1) -> i -= num
    assert i
    i
  ok result1.join(' ') is '4 3 2 1'

  j = 5
  result2 = until do (num = 1) -> (j -= num) < 1
    assert j
    j
  ok result2.join(' ') is '4 3 2 1'

test "#3921: \`switch\`", ->
  i = 1
  a = switch do (m = 2) -> i * m
    when 5 then "five"
    when 4 then "four"
    when 3 then "three"
    when 2 then "two"
    when 1 then "one"
    else "none"
  eq "two", a

  j = 12
  b = switch do (m = 3) -> j / m
    when 5 then "five"
    when 4 then "four"
    when 3 then "three"
    when 2 then "two"
    when 1 then "one"
    else "none"
  eq "four", b

  k = 20
  c = switch do (m = 4) -> k / m
    when 5 then "five"
    when 4 then "four"
    when 3 then "three"
    when 2 then "two"
    when 1 then "one"
    else "none"
  eq "five", c

# Issue #3909: backslash to break line in \`for\` loops throw syntax error
test "#3909: backslash \`for own ... of\`", ->

  obj = {a: 1, b: 2, c: 3}
  arr = ['a', 'b', 'c']

  x1 \\
    = ( key for own key of obj )
  arrayEq x1, arr

  x2 = \\
    ( key for own key of obj )
  arrayEq x2, arr

  x3 = ( \\
    key for own key of obj )
  arrayEq x3, arr

  x4 = ( key \\
    for own key of obj )
  arrayEq x4, arr

  x5 = ( key for own key of \\
    obj )
  arrayEq x5, arr

  x6 = ( key for own key of obj \\
    )
  arrayEq x6, arr

  x7 = ( key for \\
    own key of obj )
  arrayEq x7, arr

  x8 = ( key for own \\
    key of obj )
  arrayEq x8, arr

  x9 = ( key for own key \\
    of obj )
  arrayEq x9, arr


test "#3909: backslash \`for ... of\`", ->
  obj = {a: 1, b: 2, c: 3}
  arr = ['a', 'b', 'c']

  x1 \\
    = ( key for key of obj )
  arrayEq x1, arr

  x2 = \\
    ( key for key of obj )
  arrayEq x2, arr

  x3 = ( \\
    key for key of obj )
  arrayEq x3, arr

  x4 = ( key \\
    for key of obj )
  arrayEq x4, arr

  x5 = ( key for key of \\
    obj )
  arrayEq x5, arr

  x6 = ( key for key of obj \\
    )
  arrayEq x6, arr

  x7 = ( key for \\
    key of obj )
  arrayEq x7, arr

  x8 = ( key for key \\
    of obj )
  arrayEq x8, arr


test "#3909: backslash \`for ... in\`", ->
  arr = ['a', 'b', 'c']

  x1 \\
    = ( key for key in arr )
  arrayEq x1, arr

  x2 = \\
    ( key for key in arr )
  arrayEq x2, arr

  x3 = ( \\
    key for key in arr )
  arrayEq x3, arr

  x4 = ( key \\
    for key in arr )
  arrayEq x4, arr

  x5 = ( key for key in \\
    arr )
  arrayEq x5, arr

  x6 = ( key for key in arr \\
    )
  arrayEq x6, arr

  x7 = ( key for \\
    key in arr )
  arrayEq x7, arr

  x8 = ( key for key \\
    in arr )
  arrayEq x8, arr

if a then b else if c then d else if e then f else g

if no
  1
else if yes
  2

test "#4898: Lexer: backslash line continuation is inconsistent", ->
  if ( \\
      false \\
      or \\
      true \\
    )
    a = 42

  eq a, 42

  if ( \\
      false \\
      or \\
      true \\
  )
    b = 42

  eq b, 42

  if ( \\
            false \\
         or \\
   true \\
  )
    c = 42

  eq c, 42

  if \\
   false \\
        or \\
   true
    d = 42

  eq d, 42

  if \\
              false or \\
  true
    e = 42

  eq e, 42

  if \\
       false or \\
    true \\
       then \\
   f = 42 \\
   else
     f = 24

  eq f, 42
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
id = (_) ->
  if arguments.length is 1
    _
  else
    Array::slice.call arguments

test "basic conditionals", ->
  if false
    ok false
  else if false
    ok false
  else
    ok true

  if true
    ok true
  else if true
    ok false
  else
    ok true

  unless true
    ok false
  else unless true
    ok false
  else
    ok true

  unless false
    ok true
  else unless false
    ok false
  else
    ok true

test "single-line conditional", ->
  if false
    ok false
  else
    ok true
  unless false
    ok true
  else
    ok false

test "nested conditionals", ->
  nonce = {}
  eq(
    nonce
    if true
      unless false
        if false
          false
        else if true
          nonce
  )

test "nested single-line conditionals", ->
  nonce = {}

  a =
    if false
      undefined
    else
      (b =
        if 0
          undefined
        else
          nonce)
  eq nonce, a
  eq nonce, b

  c =
    if false
      undefined
    else if 0
      undefined
    else
      nonce
  eq nonce, c

  d =
    if true
      id(
        if false
          undefined
        else
          nonce
      )
  eq nonce, d

test "empty conditional bodies", ->
  eq(
    undefined
    if false
    else if false
    else
  )

test "conditional bodies containing only comments", ->
  eq(
    undefined
    if true
    else
  )

  eq(
    undefined
    if false
    else if true
    else
  )

test "return value of if-else is from the proper body", ->
  nonce = {}
  eq(
    nonce
    if false
      undefined
    else
      nonce
  )

test "return value of unless-else is from the proper body", ->
  nonce = {}
  eq(
    nonce
    unless true
      undefined
    else
      nonce
  )

test "assign inside the condition of a conditional statement", ->
  nonce = {}
  if (a = nonce)
    1
  eq nonce, a
  1 if (b = nonce)
  eq nonce, b

test "single-line function definition with single-line conditional", ->
  fn = ->
    if 1 < 0.5
      1
    else
      -1
  ok fn() is -1

test "function resturns conditional value with no \`else\`", ->
  fn = -> return (if false then true)
  eq undefined, fn()

test "function returns a conditional value", ->
  a = {}
  fnA = -> return (if false then undefined else a)
  eq a, fnA()

  b = {}
  fnB = -> return (unless false then b else undefined)
  eq b, fnB()

test "passing a conditional value to a function", ->
  nonce = {}
  eq(
    nonce
    id(
      if false
        undefined
      else
        nonce
    )
  )

test "unmatched \`then\` should catch implicit calls", ->
  a = 0
  trueFn = -> true
  if trueFn(undefined)
    a++
  eq 1, a

test "if-to-ternary with instanceof requires parentheses", ->
  nonce = {}
  eq(
    nonce
    if {} instanceof Object
      nonce
    else
      undefined
  )

test "if-to-ternary as part of a larger operation requires parentheses", ->
  ok 2, 1 + (if false then 0 else 1)

test "if-else indented within an assignment", ->
  nonce = {}
  result =
    if false
      undefined
    else
      nonce
  eq nonce, result

test "suppressed indentation via assignment", ->
  nonce = {}
  result =
    if false
      undefined
    else if no
      undefined
    else if 0
      undefined
    else if 1 < 0
      undefined
    else
      id(
        if false
          undefined
        else
          nonce
      )
  eq nonce, result

test "tight formatting with leading \`then\`", ->
  nonce = {}
  eq(
    nonce
    if true
      nonce
    else
      undefined
  )

test "#738: inline function defintion", ->
  nonce = {}
  fn =
    if true
      -> nonce
  eq nonce, fn()

test "#748: trailing reserved identifiers", ->
  nonce = {}
  obj = delete: true
  result =
    if obj.delete
      nonce
  eq nonce, result

test "if-else within an assignment, condition parenthesized", ->
  result =
    if 1 is 1
      "correct"
  eq result, "correct"

  result =
    if "whatever" ? no
      "correct"
  eq result, "correct"

  f = -> "wrong"
  result =
    if f?()
      "correct"
    else
      "wrong"
  eq result, "correct"

test "#3056: multiple postfix conditionals", ->
  temp = "initial"
  temp = "ignored" unless true if false
  eq temp, "initial"

test "basic \`while\` loops", ->
  i = 5
  list =
    while i -= 1
      i * 2
  ok list.join(" ") is "8 6 4 2"

  i = 5
  list = (i * 3 while i -= 1)
  ok list.join(" ") is "12 9 6 3"

  i = 5
  func = (num) -> i -= num
  assert = -> ok i < 5 > 0
  results =
    while func(1)
      assert()
      i
  ok results.join(" ") is "4 3 2 1"

  i = 10
  results =
    while i -= 1 when i % 2 is 0
      i * 2
  ok results.join(" ") is "16 12 8 4"

test "Issue 759: \`if\` within \`while\` condition", ->
  2 while (
    if 1
      0
  )

test "assignment inside the condition of a \`while\` loop", ->
  nonce = {}
  count = 1
  a = nonce while count--
  eq nonce, a
  count = 1
  while count--
    b = nonce
  eq nonce, b

test "While over break.", ->
  i = 0
  result =
    while i < 10
      i++
      break
  arrayEq result, []

test "While over continue.", ->
  i = 0
  result =
    while i < 10
      i++
      continue
  arrayEq result, []

test "Basic \`until\`", ->
  value = false
  i = 0
  results =
    until value
      value = true if i is 5
      i++
  ok i is 6

test "Basic \`loop\`", ->
  i = 5
  list = []
  loop
    i -= 1
    break if i is 0
    list.push i * 2
  ok list.join(" ") is "8 6 4 2"

test "break at the top level", ->
  for i in [1, 2, 3]
    result = i
    if i == 2
      break
  eq 2, result

test "break *not* at the top level", ->
  someFunc = ->
    i = 0
    while ++i < 3
      result = i
      break if i > 1
    result
  eq 2, someFunc()

test "basic \`switch\`", ->
  num = 10
  result =
    switch num
      when 5
        false
      when "a"
        true
        true
        false
      when 10
        true
      when 11
        false
      else
        false

  ok result

  func = (num) ->
    switch num
      when 2, 4, 6
        true
      when 1, 3, 5
        false

  ok func 2
  ok func 6
  ok !func(3)
  eq func(8), undefined

test "Ensure that trailing switch elses don't get rewritten.", ->
  result = false
  switch "word"
    when "one thing"
      doSomething()
    else
      result = true unless false

  ok result

  result = false
  switch "word"
    when "one thing"
      doSomething()
    when "other thing"
      doSomething()
    else
      result = true unless false

  ok result

test "Should be able to handle switches sans-condition.", ->
  result =
    switch
      when null
        0
      when !1
        1
      when "" not of { "" }
        2
      when [] not instanceof Array
        3
      when true is false
        4
      when "x" < "y" > "z"
        5
      when "a" in ["b", "c"]
        6
      when "d" in ["e", "f"]
        7
      else
        ok

  eq result, ok

test "Should be able to use \`@properties\` within the switch clause.", ->
  obj =
    num: 101
    func: ->
      switch @num
        when 101
          "101!"
        else
          "other"

  ok obj.func() is "101!"

test "Should be able to use \`@properties\` within the switch cases.", ->
  obj =
    num: 101
    func: (yesOrNo) ->
      result =
        switch yesOrNo
          when yes
            @num
          else
            "other"
      result

  ok obj.func(yes) is 101

test "Switch with break as the return value of a loop.", ->
  i = 10
  results =
    while i > 0
      i--
      switch i % 2
        when 1
          i
        when 0
          break

  eq results.join(", "), "9, 7, 5, 3, 1"

test "Issue #997. Switch doesn't fallthrough.", ->
  val = 1
  switch true
    when true
      if false
        return 5
    else
      val = 2

  eq val, 1

test "Throw should be usable as an expression.", ->
  try
    false or throw "up"
    throw new Error "failed"
  catch e
    ok e is "up"

test "#2555, strange function if bodies", ->
  success = -> ok true
  failure = -> ok false

  success() if do ->
    yes

  failure() if (
    try
      false
  )

test "#1057: \`catch\` or \`finally\` in single-line functions", ->
  ok do ->
    try
      throw "up"
    catch
      yes
  ok do ->
    try
      yes
    finally
      "nothing"

test "#2367: super in for-loop", ->
  class Foo
    sum: 0
    add: (val) ->
      @sum += val

  class Bar extends Foo
    add: (vals...) ->
      super val for val in vals
      @sum

  eq 10, new Bar().add 2, 3, 5

test "#4267: lots of for-loops in the same scope", ->
  code = """
    do ->
      #{Array(200).join "for [0..0] then\\n  "}
      true
  """
  ok CoffeeScript.eval code

test "#2343: if / then / if / then / else", ->
  a = b = yes
  c = e = g = no
  d = 1
  f = 2
  h = 3
  i = 4

  s = ->
    if a
      if b
        if c
          d
        else if e
          f
        else if g
          h
        else
          i

  t = ->
    if a
      if b
        if c
          d
        else if e
          f
        else if g
          h
        else
          i

  u = ->
    if a
      if b
        if c
          d
        else if e
          f
        else if g
          h
        else
          i

  v = ->
    if a
      if b
        if c
          d
        else if e
          f
        else if g
          h
        else
          i

  w = ->
    if a
      if b
        if c
          d
        else if e
          f
        else if g
          h
        else
          i

  x = ->
    if a
      if b
        if c
          d
        else if e
          f
        else if g
          h
        else
          i

  y = ->
    if a
      if b
        if c
          d
        else if e
          f
        else if g
          h
        else
          i

  eq 4, s()
  eq 4, t()
  eq 4, u()
  eq 4, v()
  eq 4, w()
  eq 4, x()
  eq 4, y()

  c = yes
  eq 1, s()
  eq 1, t()
  eq 1, u()
  eq 1, v()
  eq 1, w()
  eq 1, x()
  eq 1, y()

  b = no
  eq undefined, s()
  eq undefined, t()
  eq undefined, u()
  eq undefined, v()
  eq undefined, w()
  eq undefined, x()
  eq undefined, y()

test "#2343: if / then / if / then / else / else", ->
  a = b = yes
  c = e = g = no
  d = 1
  f = 2
  h = 3
  i = 4
  j = 5
  k = 6

  s = ->
    if a
      if b
        if c
          d
        else
          e
          if e
            f
          else if g
            h
          else
            i
      else
        j
    else
      k

  t = ->
    if a
      if b
        if c
          d
        else if e
          f
        else if g
          h
        else
          i
      else
        j
    else
      k

  u = ->
    if a
      if b
        if c
          d
        else if e
          f
        else if g
          h
        else
          i
      else
        j
    else
      k

  v = ->
    if a
      if b
        if c
          d
        else if e
          f
        else if g
          h
        else
          i
      else
        j
    else
      k

  w = ->
    if a
      if b
        if c
          d
        else if e
          f
        else if g
          h
        else
          i
      else
        j
    else
      k

  x = ->
    if a
      if b
        if c
          d
        else if e
          f
        else if g
          h
        else
          i
      else
        j
    else
      k

  y = ->
    if a
      if b
        if c
          d
        else if e
          f
        else if g
          h
        else
          i
      else
        j
    else
      k

  eq 4, s()
  eq 4, t()
  eq 4, u()
  eq 4, v()
  eq 4, w()
  eq 4, x()
  eq 4, y()

  c = yes
  eq 1, s()
  eq 1, t()
  eq 1, u()
  eq 1, v()
  eq 1, w()
  eq 1, x()
  eq 1, y()

  b = no
  eq 5, s()
  eq 5, t()
  eq 5, u()
  eq 5, v()
  eq 5, w()
  eq 5, x()
  eq 5, y()

  a = no
  eq 6, s()
  eq 6, t()
  eq 6, u()
  eq 6, v()
  eq 6, w()
  eq 6, x()
  eq 6, y()

test "#2343: switch / when / then / if / then / else", ->
  a = b = yes
  c = e = g = no
  d = 1
  f = 2
  h = 3
  i = 4

  s = ->
    switch
      when a
        if b
          if c
            d
          else if e
            f
          else if g
            h
          else
            i

  t = ->
    switch
      when a
        if b
          if c
            d
          else if e
            f
          else if g
            h
          else
            i

  u = ->
    switch
      when a
        if b
          if c
            d
          else if e
            f
          else if g
            h
          else
            i

  v = ->
    switch
      when a
        if b
          if c
            d
          else if e
            f
          else if g
            h
          else
            i

  w = ->
    switch
      when a
        if b
          if c
            d
          else if e
            f
          else if g
            h
          else
            i

  x = ->
    switch
      when a
        if b
          if c
            d
          else if e
            f
          else if g
            h
          else
            i

  y = ->
    switch
      when a
        if b
          if c
            d
          else if e
            f
          else if g
            h
          else
            i

  eq 4, s()
  eq 4, t()
  eq 4, u()
  eq 4, v()
  eq 4, w()
  eq 4, x()
  eq 4, y()

  c = yes
  eq 1, s()
  eq 1, t()
  eq 1, u()
  eq 1, v()
  eq 1, w()
  eq 1, x()
  eq 1, y()

  b = no
  eq undefined, s()
  eq undefined, t()
  eq undefined, u()
  eq undefined, v()
  eq undefined, w()
  eq undefined, x()
  eq undefined, y()

test "#2343: switch / when / then / if / then / else / else", ->
  a = b = yes
  c = e = g = no
  d = 1
  f = 2
  h = 3
  i = 4

  s = ->
    switch
      when a
        if b
          if c
            d
          else if e
            f
          else if g
            h
          else
            i
      else
        0

  t = ->
    switch
      when a
        if b
          if c
            d
          else if e
            f
          else if g
            h
          else
            i
      else
        0

  u = ->
    switch
      when a
        if b
          if c
            d
          else if e
            f
          else if g
            h
          else
            i
      else
        0

  v = ->
    switch
      when a
        if b
          if c
            d
          else if e
            f
          else if g
            h
          else
            i
      else
        0

  w = ->
    switch
      when a
        if b
          if c
            d
          else if e
            f
          else if g
            h
          else
            i
      else
        0

  x = ->
    switch
      when a
        if b
          if c
            d
          else if e
            f
          else if g
            h
          else
            i
      else
        0

  y = ->
    switch
      when a
        if b
          if c
            d
          else if e
            f
          else if g
            h
          else
            i
      else
        0

  eq 4, s()
  eq 4, t()
  eq 4, u()
  eq 4, v()
  eq 4, w()
  eq 4, x()
  eq 4, y()

  c = yes
  eq 1, s()
  eq 1, t()
  eq 1, u()
  eq 1, v()
  eq 1, w()
  eq 1, x()
  eq 1, y()

  b = no
  eq undefined, s()
  eq undefined, t()
  eq undefined, u()
  eq undefined, v()
  eq undefined, w()
  eq undefined, x()
  eq undefined, y()

  b = yes
  a = no
  eq 0, s()
  eq 0, t()
  eq 0, u()
  eq 0, v()
  eq 0, w()
  eq 0, x()
  eq 0, y()

test "#2343: switch / when / then / if / then / else / else / else", ->
  a = b = yes
  c = e = g = no
  d = 1
  f = 2
  h = 3
  i = 4
  j = 5

  s = ->
    switch
      when a
        if b
          if c
            d
          else if e
            f
          else if g
            h
          else
            i
        else
          j
      else
        0

  t = ->
    switch
      when a
        if b
          if c
            d
          else if e
            f
          else if g
            h
          else
            i
        else
          j
      else
        0

  u = ->
    switch
      when a
        if b
          if c
            d
          else if e
            f
          else if g
            h
          else
            i
        else
          j
      else
        0

  v = ->
    switch
      when a
        if b
          if c
            d
          else if e
            f
          else if g
            h
          else
            i
        else
          j
      else
        0

  w = ->
    switch
      when a
        if b
          if c
            d
          else if e
            f
          else if g
            h
          else
            i
        else
          j
      else
        0

  x = ->
    switch
      when a
        if b
          if c
            d
          else if e
            f
          else if g
            h
          else
            i
        else
          j
      else
        0

  y = ->
    switch
      when a
        if b
          if c
            d
          else if e
            f
          else if g
            h
          else
            i
        else
          j
      else
        0

  eq 4, s()
  eq 4, t()
  eq 4, u()
  eq 4, v()
  eq 4, w()
  eq 4, x()
  eq 4, y()

  c = yes
  eq 1, s()
  eq 1, t()
  eq 1, u()
  eq 1, v()
  eq 1, w()
  eq 1, x()
  eq 1, y()

  b = no
  eq 5, s()
  eq 5, t()
  eq 5, u()
  eq 5, v()
  eq 5, w()
  eq 5, x()
  eq 5, y()

  b = yes
  a = no
  eq 0, s()
  eq 0, t()
  eq 0, u()
  eq 0, v()
  eq 0, w()
  eq 0, x()
  eq 0, y()

test "#3921: \`if\` & \`unless\`", ->
  a = {}
  eq(
    a
    if (
      do ->
        no
    )
      undefined
    else
      a
  )
  a1 = undefined
  if (
    do ->
      yes
  )
    a1 = a
  eq a, a1

  b = {}
  eq(
    b
    unless (
      do ->
        no
    )
      b
    else
      undefined
  )
  b1 = undefined
  unless (
    do ->
      no
  )
    b1 = b
  eq b, b1

  c = 0
  if (arg = undefined) -> yes
    c++
  eq 1, c
  d = 0
  if (arg = undefined) -> yes
    d++
  eq 1, d

  answer = "correct"
  eq(
    answer
    if (
      do ->
        "wrong"
    )
      "correct"
    else
      "wrong"
  )
  eq(
    answer
    unless (
      do ->
        no
    )
      "correct"
    else
      "wrong"
  )
  statm1 = undefined
  if (
    do ->
      "wrong"
  )
    statm1 = "correct"
  eq answer, statm1
  statm2 = undefined
  unless (
    do ->
      no
  )
    statm2 = "correct"
  eq answer, statm2

test "#3921: \`post if\`", ->
  a = {}
  eq a, a unless do ->
    no
  a1 = a if do ->
    yes
  eq a, a1

  c = 0
  c++ if (arg = undefined) -> yes
  eq 1, c
  d = 0
  d++ if (arg = undefined) -> yes
  eq 1, d

  answer = "correct"
  eq answer, "correct" if do ->
    "wrong"
  eq answer, "correct" unless do ->
    not "wrong"
  statm1 = undefined
  statm1 = "correct" if do ->
    "wrong"
  eq answer, statm1
  statm2 = undefined
  statm2 = "correct" unless do ->
    not "wrong"
  eq answer, statm2

test "Issue 3921: \`while\` & \`until\`", ->
  i = 5
  assert = (a) -> ok 5 > a > 0
  result1 =
    while (
      do (num = 1) ->
        i -= num
    )
      assert i
      i
  ok result1.join(" ") is "4 3 2 1"

  j = 5
  result2 =
    until (
      do (num = 1) ->
        (j -= num) < 1
    )
      assert j
      j
  ok result2.join(" ") is "4 3 2 1"

test "#3921: \`switch\`", ->
  i = 1
  a =
    switch (
      do (m = 2) ->
        i * m
    )
      when 5
        "five"
      when 4
        "four"
      when 3
        "three"
      when 2
        "two"
      when 1
        "one"
      else
        "none"
  eq "two", a

  j = 12
  b =
    switch (
      do (m = 3) ->
        j / m
    )
      when 5
        "five"
      when 4
        "four"
      when 3
        "three"
      when 2
        "two"
      when 1
        "one"
      else
        "none"
  eq "four", b

  k = 20
  c =
    switch (
      do (m = 4) ->
        k / m
    )
      when 5
        "five"
      when 4
        "four"
      when 3
        "three"
      when 2
        "two"
      when 1
        "one"
      else
        "none"
  eq "five", c

test "#3909: backslash \`for own ... of\`", ->
  obj = a: 1, b: 2, c: 3
  arr = ["a", "b", "c"]

  x1 = (key for own key of obj)
  arrayEq x1, arr

  x2 = (key for own key of obj)
  arrayEq x2, arr

  x3 = (key for own key of obj)
  arrayEq x3, arr

  x4 = (key for own key of obj)
  arrayEq x4, arr

  x5 = (key for own key of obj)
  arrayEq x5, arr

  x6 = (key for own key of obj)
  arrayEq x6, arr

  x7 = (key for own key of obj)
  arrayEq x7, arr

  x8 = (key for own key of obj)
  arrayEq x8, arr

  x9 = (key for own key of obj)
  arrayEq x9, arr

test "#3909: backslash \`for ... of\`", ->
  obj = a: 1, b: 2, c: 3
  arr = ["a", "b", "c"]

  x1 = (key for key of obj)
  arrayEq x1, arr

  x2 = (key for key of obj)
  arrayEq x2, arr

  x3 = (key for key of obj)
  arrayEq x3, arr

  x4 = (key for key of obj)
  arrayEq x4, arr

  x5 = (key for key of obj)
  arrayEq x5, arr

  x6 = (key for key of obj)
  arrayEq x6, arr

  x7 = (key for key of obj)
  arrayEq x7, arr

  x8 = (key for key of obj)
  arrayEq x8, arr

test "#3909: backslash \`for ... in\`", ->
  arr = ["a", "b", "c"]

  x1 = (key for key in arr)
  arrayEq x1, arr

  x2 = (key for key in arr)
  arrayEq x2, arr

  x3 = (key for key in arr)
  arrayEq x3, arr

  x4 = (key for key in arr)
  arrayEq x4, arr

  x5 = (key for key in arr)
  arrayEq x5, arr

  x6 = (key for key in arr)
  arrayEq x6, arr

  x7 = (key for key in arr)
  arrayEq x7, arr

  x8 = (key for key in arr)
  arrayEq x8, arr

if a
  b
else if c
  d
else if e
  f
else
  g

if no
  1
else if yes
  2

test "#4898: Lexer: backslash line continuation is inconsistent", ->
  if false or true
    a = 42

  eq a, 42

  if false or true
    b = 42

  eq b, 42

  if false or true
    c = 42

  eq c, 42

  if false or true
    d = 42

  eq d, 42

  if false or true
    e = 42

  eq e, 42

  if false or true
    f = 42
  else
    f = 24

  eq f, 42

`;

exports[`exception_handling.coffee 1`] = `
# Exception Handling
# ------------------

# shared nonce
nonce = {}


# Throw

test "basic exception throwing", ->
  throws (-> throw 'error'), /^error$/


# Empty Try/Catch/Finally

test "try can exist alone", ->
  try

test "try/catch with empty try, empty catch", ->
  try
    # nothing
  catch err
    # nothing

test "single-line try/catch with empty try, empty catch", ->
  try catch err

test "try/finally with empty try, empty finally", ->
  try
    # nothing
  finally
    # nothing

test "single-line try/finally with empty try, empty finally", ->
  try finally

test "try/catch/finally with empty try, empty catch, empty finally", ->
  try
  catch err
  finally

test "single-line try/catch/finally with empty try, empty catch, empty finally", ->
  try catch err then finally


# Try/Catch/Finally as an Expression

test "return the result of try when no exception is thrown", ->
  result = try
    nonce
  catch err
    undefined
  finally
    undefined
  eq nonce, result

test "single-line result of try when no exception is thrown", ->
  result = try nonce catch err then undefined
  eq nonce, result

test "return the result of catch when an exception is thrown", ->
  fn = ->
    try
      throw ->
    catch err
      nonce
  doesNotThrow fn
  eq nonce, fn()

test "single-line result of catch when an exception is thrown", ->
  fn = ->
    try throw (->) catch err then nonce
  doesNotThrow fn
  eq nonce, fn()

test "optional catch", ->
  fn = ->
    try throw ->
    nonce
  doesNotThrow fn
  eq nonce, fn()


# Try/Catch/Finally Interaction With Other Constructs

test "try/catch with empty catch as last statement in a function body", ->
  fn = ->
    try nonce
    catch err
  eq nonce, fn()

test "#1595: try/catch with a reused variable name", ->
  # \`catch\` shouldn’t lead to broken scoping.
  do ->
    try
      inner = 5
    catch inner
      # nothing
  eq typeof inner, 'undefined'

test "#2580: try/catch with destructuring the exception object", ->
  result = try
    missing.object
  catch {message}
    message

  eq message, 'missing is not defined'

test "Try catch finally as implicit arguments", ->
  first = (x) -> x

  foo = no
  try
    first try iamwhoiam() finally foo = yes
  catch e
  eq foo, yes

  bar = no
  try
    first try iamwhoiam() catch e finally
    bar = yes
  catch e
  eq bar, yes

test "#2900: parameter-less catch clause", ->
  # \`catch\` should not require a parameter.
  try
    throw new Error 'failed'
  catch
    ok true

  try throw new Error 'failed' catch finally ok true

  ok try throw new Error 'failed' catch then true

test "#3709: throwing an if statement", ->
  # \`throw if\` should return a closure around the \`if\` block, so that the
  # output is valid JavaScript.
  try
    throw if no
        new Error 'drat!'
      else
        new Error 'no escape!'
  catch err
    eq err.message, 'no escape!'

  try
    throw if yes then new Error 'huh?' else null
  catch err
    eq err.message, 'huh?'

test "#3709: throwing a switch statement", ->
  i = 3
  try
    throw switch i
      when 2
        new Error 'not this one'
      when 3
        new Error 'oh no!'
  catch err
    eq err.message, 'oh no!'

test "#3709: throwing a for loop", ->
  # \`throw for\` should return a closure around the \`for\` block, so that the
  # output is valid JavaScript.
  try
    throw for i in [0..3]
      i * 2
  catch err
    arrayEq err, [0, 2, 4, 6]

test "#3709: throwing a while loop", ->
  i = 0
  try
    throw while i < 3
      i++
  catch err
    eq i, 3

test "#3789: throwing a throw", ->
  try
    throw throw throw new Error 'whoa!'
  catch err
    eq err.message, 'whoa!'
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
nonce = {}

test "basic exception throwing", -> throws (-> throw "error"), /^error$/

test "try can exist alone", ->
  try

test "try/catch with empty try, empty catch", ->
  try
  catch err
test "single-line try/catch with empty try, empty catch", ->
  try
  catch err

test "try/finally with empty try, empty finally", ->
  try
  finally
test "single-line try/finally with empty try, empty finally", ->
  try
  finally

test "try/catch/finally with empty try, empty catch, empty finally", ->
  try
  catch err
  finally

test "single-line try/catch/finally with empty try, empty catch, empty finally", ->
  try
  catch err
  finally

test "return the result of try when no exception is thrown", ->
  result =
    try
      nonce
    catch err
      undefined
    finally
      undefined
  eq nonce, result

test "single-line result of try when no exception is thrown", ->
  result =
    try
      nonce
    catch err
      undefined
  eq nonce, result

test "return the result of catch when an exception is thrown", ->
  fn = ->
    try
      throw ->
    catch err
      nonce
  doesNotThrow fn
  eq nonce, fn()

test "single-line result of catch when an exception is thrown", ->
  fn = ->
    try
      throw ->
    catch err
      nonce
  doesNotThrow fn
  eq nonce, fn()

test "optional catch", ->
  fn = ->
    try
      throw ->
    nonce
  doesNotThrow fn
  eq nonce, fn()

test "try/catch with empty catch as last statement in a function body", ->
  fn = ->
    try
      nonce
    catch err
  eq nonce, fn()

test "#1595: try/catch with a reused variable name", ->
  do ->
    try
      inner = 5
    catch inner
  eq typeof inner, "undefined"

test "#2580: try/catch with destructuring the exception object", ->
  result =
    try
      missing.object
    catch { message }
      message

  eq message, "missing is not defined"

test "Try catch finally as implicit arguments", ->
  first = (x) -> x

  foo = no
  try
    first(
      try
        iamwhoiam()
      finally
        foo = yes
    )
  catch e
  eq foo, yes

  bar = no
  try
    first(
      try
        iamwhoiam()
      catch e
      finally
    )
    bar = yes
  catch e
  eq bar, yes

test "#2900: parameter-less catch clause", ->
  try
    throw new Error "failed"
  catch
    ok true

  try
    throw new Error "failed"
  catch
  finally
    ok true

  ok(
    try
      throw new Error "failed"
    catch
      true
  )

test "#3709: throwing an if statement", ->
  try
    throw (if no then new Error "drat!" else new Error "no escape!")
  catch err
    eq err.message, "no escape!"

  try
    throw (if yes then new Error "huh?" else null)
  catch err
    eq err.message, "huh?"

test "#3709: throwing a switch statement", ->
  i = 3
  try
    throw switch i
      when 2
        new Error "not this one"
      when 3
        new Error "oh no!"
  catch err
    eq err.message, "oh no!"

test "#3709: throwing a for loop", ->
  try
    throw for i in [0..3]
      i * 2
  catch err
    arrayEq err, [0, 2, 4, 6]

test "#3709: throwing a while loop", ->
  i = 0
  try
    throw while i < 3
      i++
  catch err
    eq i, 3

test "#3789: throwing a throw", ->
  try
    throw throw throw new Error "whoa!"
  catch err
    eq err.message, "whoa!"

`;

exports[`exponentiation.coffee 1`] = `
# The \`**\` and \`**=\` operators are only supported in Node 7.5+, so the tests
# for these exponentiation operators are split out into their own file to be
# loaded only by supported runtimes.

test "exponentiation operator", ->
  eq 27, 3 ** 3

test "exponentiation operator has higher precedence than other maths operators", ->
  eq 55, 1 + 3 ** 3 * 2
  eq -4, -2 ** 2
  eq 0, (!2) ** 2

test "exponentiation operator is right associative", ->
  eq 2, 2 ** 1 ** 3

test "exponentiation operator compound assignment", ->
  a = 2
  a **= 3
  eq 8, a
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
test "exponentiation operator", -> eq 27, 3 ** 3

test "exponentiation operator has higher precedence than other maths operators", ->
  eq 55, 1 + 3 ** 3 * 2
  eq -4, -(2 ** 2)
  eq 0, (!2) ** 2

test "exponentiation operator is right associative", -> eq 2, 2 ** (1 ** 3)

test "exponentiation operator compound assignment", ->
  a = 2
  a **= 3
  eq 8, a

`;

exports[`functions.coffee 1`] = `
# Function Literals
# -----------------

# TODO: add indexing and method invocation tests: (->)[0], (->).call()

# * Function Definition
# * Bound Function Definition
# * Parameter List Features
#   * Splat Parameters
#   * Context (@) Parameters
#   * Parameter Destructuring
#   * Default Parameters

# Function Definition

x = 1
y = {}
y.x = -> 3
ok x is 1
ok typeof(y.x) is 'function'
ok y.x instanceof Function
ok y.x() is 3

# The empty function should not cause a syntax error.
->
() ->

# Multiple nested function declarations mixed with implicit calls should not
# cause a syntax error.
(one) -> (two) -> three four, (five) -> six seven, eight, (nine) ->

# with multiple single-line functions on the same line.
func = (x) -> (x) -> (x) -> x
ok func(1)(2)(3) is 3

# Make incorrect indentation safe.
func = ->
  obj = {
          key: 10
        }
  obj.key - 5
eq func(), 5

# Ensure that functions with the same name don't clash with helper functions.
del = -> 5
ok del() is 5


# Bound Function Definition

obj =
  bound: ->
    (=> this)()
  unbound: ->
    (-> this)()
  nested: ->
    (=>
      (=>
        (=> this)()
      )()
    )()
eq obj, obj.bound()
ok obj isnt obj.unbound()
eq obj, obj.nested()


test "even more fancy bound functions", ->
  obj =
    one: ->
      do =>
        return this.two()
    two: ->
      do =>
        do =>
          do =>
            return this.three
    three: 3

  eq obj.one(), 3


test "arguments in bound functions inherit from parent function", ->
  # The \`arguments\` object in an ES arrow function refers to the \`arguments\`
  # of the parent scope, just like \`this\`. In the CoffeeScript 1.x
  # implementation of \`=>\`, the \`arguments\` object referred to the arguments
  # of the arrow function; but per the ES2015 spec, \`arguments\` should refer
  # to the parent.
  arrayEq ((a...) -> a)([1, 2, 3]), ((a...) => a)([1, 2, 3])

  parent = (a, b, c) ->
    (bound = =>
      [arguments[0], arguments[1], arguments[2]]
    )()
  arrayEq [1, 2, 3], parent(1, 2, 3)


test "self-referencing functions", ->
  changeMe = ->
    changeMe = 2

  changeMe()
  eq changeMe, 2


# Parameter List Features

test "splats", ->
  arrayEq [0, 1, 2], (((splat...) -> splat) 0, 1, 2)
  arrayEq [2, 3], (((_, _1, splat...) -> splat) 0, 1, 2, 3)
  arrayEq [0, 1], (((splat..., _, _1) -> splat) 0, 1, 2, 3)
  arrayEq [2], (((_, _1, splat..., _2) -> splat) 0, 1, 2, 3)

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  arrayEq [0, 1, 2], (((splat ...) -> splat) 0, 1, 2)
  arrayEq [2, 3], (((_, _1, splat ...) -> splat) 0, 1, 2, 3)
  arrayEq [0, 1], (((splat ..., _, _1) -> splat) 0, 1, 2, 3)
  arrayEq [2], (((_, _1, splat ..., _2) -> splat) 0, 1, 2, 3)

test "destructured splatted parameters", ->
  arr = [0,1,2]
  splatArray = ([a...]) -> a
  splatArrayRest = ([a...],b...) -> arrayEq(a,b); b
  arrayEq splatArray(arr), arr
  arrayEq splatArrayRest(arr,0,1,2), arr

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  splatArray = ([a ...]) -> a
  splatArrayRest = ([a ...],b ...) -> arrayEq(a,b); b

test "#4884: object-destructured splatted parameters", ->
  f = ({length}...) -> length
  eq f(4, 5, 6), 3
  f = ({length: len}...) -> len
  eq f(4, 5, 6), 3
  f = ({length}..., last) -> [length, last]
  arrayEq f(4, 5, 6), [2, 6]
  f = ({length: len}..., last) -> [len, last]
  arrayEq f(4, 5, 6), [2, 6]

test "@-parameters: automatically assign an argument's value to a property of the context", ->
  nonce = {}

  ((@prop) ->).call context = {}, nonce
  eq nonce, context.prop

  # Allow splats alongside the special argument
  ((splat..., @prop) ->).apply context = {}, [0, 0, nonce]
  eq nonce, context.prop

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  ((splat ..., @prop) ->).apply context = {}, [0, 0, nonce]
  eq nonce, context.prop

  # Allow the argument itself to be a splat
  ((@prop...) ->).call context = {}, 0, nonce, 0
  eq nonce, context.prop[1]

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  ((@prop ...) ->).call context = {}, 0, nonce, 0
  eq nonce, context.prop[1]

  # The argument should not be able to be referenced normally
  code = '((@prop) -> prop).call {}'
  doesNotThrow -> CoffeeScript.compile code
  throws (-> CoffeeScript.run code), ReferenceError
  code = '((@prop) -> _at_prop).call {}'
  doesNotThrow -> CoffeeScript.compile code
  throws (-> CoffeeScript.run code), ReferenceError

test "@-parameters and splats with constructors", ->
  a = {}
  b = {}
  class Klass
    constructor: (@first, splat..., @last) ->

  obj = new Klass a, 0, 0, b
  eq a, obj.first
  eq b, obj.last

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  class Klass
    constructor: (@first, splat ..., @last) ->

  obj = new Klass a, 0, 0, b
  eq a, obj.first
  eq b, obj.last

test "destructuring in function definition", ->
  (([{a: [b], c}]...) ->
    eq 1, b
    eq 2, c
  ) {a: [1], c: 2}

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  (([{a: [b], c}] ...) ->
    eq 1, b
    eq 2, c
  ) {a: [1], c: 2}

  context = {}
  (([{a: [b, c = 2], @d, e = 4}]...) ->
    eq 1, b
    eq 2, c
    eq @d, 3
    eq context.d, 3
    eq e, 4
  ).call context, {a: [1], d: 3}

  (({a: aa = 1, b: bb = 2}) ->
    eq 5, aa
    eq 2, bb
  ) {a: 5}

  ajax = (url, {
    async = true,
    beforeSend = (->),
    cache = true,
    method = 'get',
    data = {}
  }) ->
    {url, async, beforeSend, cache, method, data}

  fn = ->
  deepEqual ajax('/home', beforeSend: fn, method: 'post'), {
    url: '/home', async: true, beforeSend: fn, cache: true, method: 'post', data: {}
  }

test "#4005: \`([a = {}]..., b) ->\` weirdness", ->
  fn = ([a = {}]..., b) -> [a, b]
  deepEqual fn(5), [{}, 5]

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  fn = ([a = {}] ..., b) -> [a, b]
  deepEqual fn(5), [{}, 5]

test "default values", ->
  nonceA = {}
  nonceB = {}
  a = (_,_1,arg=nonceA) -> arg
  eq nonceA, a()
  eq nonceA, a(0)
  eq nonceB, a(0,0,nonceB)
  eq nonceA, a(0,0,undefined)
  eq null, a(0,0,null) # Per ES2015, \`null\` doesn’t trigger a parameter default value
  eq false , a(0,0,false)
  eq nonceB, a(undefined,undefined,nonceB,undefined)
  b = (_,arg=nonceA,_1,_2) -> arg
  eq nonceA, b()
  eq nonceA, b(0)
  eq nonceB, b(0,nonceB)
  eq nonceA, b(0,undefined)
  eq null, b(0,null)
  eq false , b(0,false)
  eq nonceB, b(undefined,nonceB,undefined)
  c = (arg=nonceA,_,_1) -> arg
  eq nonceA, c()
  eq      0, c(0)
  eq nonceB, c(nonceB)
  eq nonceA, c(undefined)
  eq null, c(null)
  eq false , c(false)
  eq nonceB, c(nonceB,undefined,undefined)

test "default values with @-parameters", ->
  a = {}
  b = {}
  obj = f: (q = a, @p = b) -> q
  eq a, obj.f()
  eq b, obj.p

test "default values with splatted arguments", ->
  withSplats = (a = 2, b..., c = 3, d = 5) -> a * (b.length + 1) * c * d
  eq 30, withSplats()
  eq 15, withSplats(1)
  eq  5, withSplats(1,1)
  eq  1, withSplats(1,1,1)
  eq  2, withSplats(1,1,1,1)

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  withSplats = (a = 2, b ..., c = 3, d = 5) -> a * (b.length + 1) * c * d
  eq 30, withSplats()
  eq 15, withSplats(1)
  eq  5, withSplats(1,1)
  eq  1, withSplats(1,1,1)
  eq  2, withSplats(1,1,1,1)

test "#156: parameter lists with expansion", ->
  expandArguments = (first, ..., lastButOne, last) ->
    eq 1, first
    eq 4, lastButOne
    last
  eq 5, expandArguments 1, 2, 3, 4, 5

  throws (-> CoffeeScript.compile "(..., a, b...) ->"), null, "prohibit expansion and a splat"
  throws (-> CoffeeScript.compile "(...) ->"),          null, "prohibit lone expansion"

test "#156: parameter lists with expansion in array destructuring", ->
  expandArray = (..., [..., last]) ->
    last
  eq 3, expandArray 1, 2, 3, [1, 2, 3]

test "#3502: variable definitions and expansion", ->
  a = b = 0
  f = (a, ..., b) -> [a, b]
  arrayEq [1, 5], f 1, 2, 3, 4, 5
  eq 0, a
  eq 0, b

test "variable definitions and splat", ->
  a = b = 0
  f = (a, middle..., b) -> [a, middle, b]
  arrayEq [1, [2, 3, 4], 5], f 1, 2, 3, 4, 5
  eq 0, a
  eq 0, b

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  f = (a, middle ..., b) -> [a, middle, b]
  arrayEq [1, [2, 3, 4], 5], f 1, 2, 3, 4, 5
  eq 0, a
  eq 0, b

test "default values with function calls", ->
  doesNotThrow -> CoffeeScript.compile "(x = f()) ->"

(x = f()) ->

test "arguments vs parameters", ->
  doesNotThrow -> CoffeeScript.compile "f(x) ->"
  f = (g) -> g()
  eq 5, f (x) -> 5

f(x) ->

test "reserved keyword as parameters", ->
  f = (_case, @case) -> [_case, @case]
  [a, b] = f(1, 2)
  eq 1, a
  eq 2, b

  f = (@case, _case...) -> [@case, _case...]
  [a, b, c] = f(1, 2, 3)
  eq 1, a
  eq 2, b
  eq 3, c

test "reserved keyword at-splat", ->
  f = (@case...) -> @case
  [a, b] = f(1, 2)
  eq 1, a
  eq 2, b

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  f = (@case ...) -> @case
  [a, b] = f(1, 2)
  eq 1, a
  eq 2, b

test "#1574: Destructuring and a parameter named _arg", ->
  f = ({a, b}, _arg, _arg1) -> [a, b, _arg, _arg1]
  arrayEq [1, 2, 3, 4], f a: 1, b: 2, 3, 4

test "#1844: bound functions in nested comprehensions causing empty var statements", ->
  a = ((=>) for a in [0] for b in [0])
  eq 1, a.length

test "#1859: inline function bodies shouldn't modify prior postfix ifs", ->
  list = [1, 2, 3]
  return if list.some (x) -> x is 2
  ok no

test "#2258: allow whitespace-style parameter lists in function definitions", ->
  func = (
    a, b, c
  ) -> c
  eq func(1, 2, 3), 3

  func = (
    a
    b
    c
  ) -> b
  eq func(1, 2, 3), 2

test "#2621: fancy destructuring in parameter lists", ->
  func = ({ prop1: { key1 }, prop2: { key2, key3: [a, b, c] } }) ->
    eq(key2, 'key2')
    eq(a, 'a')

  func({prop1: {key1: 'key1'}, prop2: {key2: 'key2', key3: ['a', 'b', 'c']}})

test "#1435 Indented property access", ->
  rec = -> rec: rec

  eq 1, do ->
    rec()
      .rec ->
        rec()
          .rec ->
            rec.rec()
          .rec()
    1

test "#1038 Optimize trailing return statements", ->
  compile = (code) -> CoffeeScript.compile(code, bare: yes).trim().replace(/\\s+/g, " ")

  eq "(function() {});",                 compile("->")
  eq "(function() {});",                 compile("-> return")
  eq "(function() { return void 0; });", compile("-> undefined")
  eq "(function() { return void 0; });", compile("-> return undefined")
  eq "(function() { foo(); });",         compile("""
                                                 ->
                                                   foo()
                                                   return
                                                 """)

test "#4406 Destructured parameter default evaluation order with incrementing variable", ->
  i = 0
  f = ({ a = ++i }, b = ++i) -> [a, b]
  arrayEq f({}), [1, 2]

test "#4406 Destructured parameter default evaluation order with generator function", ->
  current = 0
  next    = -> ++current
  foo = ({ a = next() }, b = next()) -> [ a, b ]
  arrayEq foo({}), [1, 2]

test "Destructured parameter with default value, that itself has a default value", ->
  # Adapted from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment
  draw = ({size = 'big', coords = {x: 0, y: 0}, radius = 25} = {}) -> "#{size}-#{coords.x}-#{coords.y}-#{radius}"
  output = draw
    coords:
      x: 18
      y: 30
    radius: 30
  eq output, 'big-18-30-30'

test "#4566: destructuring with nested default values", ->
  f = ({a: {b = 1}}) ->
    b
  eq 2, f a: b: 2

test "#1043: comma after function glyph", ->
  x = (a=->, b=2) ->
    a()
  eq x(), undefined

  f = (a) -> a()
  g = f ->, 2
  eq g, undefined
  h = f(=>, 2)
  eq h, undefined

test "#3845/#3446: chain after function glyph", ->
  angular = module: -> controller: -> controller: ->

  eq undefined,
    angular.module 'foo'
    .controller 'EmailLoginCtrl', ->
    .controller 'EmailSignupCtrl', ->

  beforeEach = (f) -> f()
  getPromise = -> then: -> catch: ->

  eq undefined,
    beforeEach ->
      getPromise()
      .then (@result) =>
      .catch (@error) =>

  doThing = -> then: -> catch: (f) -> f()
  handleError = -> 3
  eq 3,
    doThing()
    .then (@result) =>
    .catch handleError

test "#4413: expressions in function parameters that create generated variables have those variables declared correctly", ->
  'use strict'
  # We’re in strict mode because we want an error to be thrown if the generated
  # variable (\`ref\`) is assigned before being declared.
  foo = -> null
  bar = -> 33
  f = (a = foo() ? bar()) -> a
  g = (a = foo() ? bar()) -> a + 1
  eq f(), 33
  eq g(), 34

test "#4657: destructured array param declarations", ->
  a = 1
  b = 2
  f = ([a..., b]) ->
  f [3, 4, 5]
  eq a, 1
  eq b, 2

test "#4657: destructured array parameters", ->
  f = ([a..., b]) -> {a, b}
  result = f [1, 2, 3, 4]
  arrayEq result.a, [1, 2, 3]
  eq result.b, 4

# TODO: add tests for newly supported shouldCache() params with default eg ([..., last] = 1) ->, (..., [..., last] = 1) ->
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
x = 1
y = {}
y.x = -> 3
ok x is 1
ok typeof y.x is "function"
ok y.x instanceof Function
ok y.x() is 3

->
->

(one) -> (two) -> three four, (five) -> six seven, eight, (nine) ->

func = (x) -> (x) -> (x) -> x
ok func(1)(2)(3) is 3

func = ->
  obj = key: 10
  obj.key - 5
eq func(), 5

del = -> 5
ok del() is 5

obj =
  bound: -> (=> @)(), unbound: -> (-> @)(), nested: -> (=> (=> (=> @)())())()
eq obj, obj.bound()
ok obj isnt obj.unbound()
eq obj, obj.nested()

test "even more fancy bound functions", ->
  obj =
    one: ->
      do =>
        return @two()
    two: ->
      do =>
        do =>
          do =>
            return @three
    three: 3

  eq obj.one(), 3

test "arguments in bound functions inherit from parent function", ->
  arrayEq ((a...) -> a)([1, 2, 3]), ((a...) => a) [1, 2, 3]

  parent = (a, b, c) ->
    (bound = => [arguments[0], arguments[1], arguments[2]])()
  arrayEq [1, 2, 3], parent 1, 2, 3

test "self-referencing functions", ->
  changeMe = -> changeMe = 2

  changeMe()
  eq changeMe, 2

test "splats", ->
  arrayEq [0, 1, 2], ((splat...) -> splat) 0, 1, 2
  arrayEq [2, 3], ((_, _1, splat...) -> splat) 0, 1, 2, 3
  arrayEq [0, 1], ((splat..., _, _1) -> splat) 0, 1, 2, 3
  arrayEq [2], ((_, _1, splat..., _2) -> splat) 0, 1, 2, 3

  arrayEq [0, 1, 2], ((splat...) -> splat) 0, 1, 2
  arrayEq [2, 3], ((_, _1, splat...) -> splat) 0, 1, 2, 3
  arrayEq [0, 1], ((splat..., _, _1) -> splat) 0, 1, 2, 3
  arrayEq [2], ((_, _1, splat..., _2) -> splat) 0, 1, 2, 3

test "destructured splatted parameters", ->
  arr = [0, 1, 2]
  splatArray = ([a...]) -> a
  splatArrayRest = ([a...], b...) ->
    arrayEq a, b
    b
  arrayEq splatArray(arr), arr
  arrayEq splatArrayRest(arr, 0, 1, 2), arr

  splatArray = ([a...]) -> a
  splatArrayRest = ([a...], b...) ->
    arrayEq a, b
    b

test "#4884: object-destructured splatted parameters", ->
  f = ({ length }...) -> length
  eq f(4, 5, 6), 3
  f = ({ length: len }...) -> len
  eq f(4, 5, 6), 3
  f = ({ length }..., last) -> [length, last]
  arrayEq f(4, 5, 6), [2, 6]
  f = ({ length: len }..., last) -> [len, last]
  arrayEq f(4, 5, 6), [2, 6]

test "@-parameters: automatically assign an argument's value to a property of the context", ->
  nonce = {}

  ((@prop) ->).call (context = {}), nonce
  eq nonce, context.prop

  ((splat..., @prop) ->).apply (context = {}), [0, 0, nonce]
  eq nonce, context.prop

  ((splat..., @prop) ->).apply (context = {}), [0, 0, nonce]
  eq nonce, context.prop

  ((@prop...) ->).call (context = {}), 0, nonce, 0
  eq nonce, context.prop[1]

  ((@prop...) ->).call (context = {}), 0, nonce, 0
  eq nonce, context.prop[1]

  code = "((@prop) -> prop).call {}"
  doesNotThrow -> CoffeeScript.compile code
  throws (-> CoffeeScript.run code), ReferenceError
  code = "((@prop) -> _at_prop).call {}"
  doesNotThrow -> CoffeeScript.compile code
  throws (-> CoffeeScript.run code), ReferenceError

test "@-parameters and splats with constructors", ->
  a = {}
  b = {}
  class Klass
    constructor: (@first, splat..., @last) ->

  obj = new Klass a, 0, 0, b
  eq a, obj.first
  eq b, obj.last

  class Klass
    constructor: (@first, splat..., @last) ->

  obj = new Klass a, 0, 0, b
  eq a, obj.first
  eq b, obj.last

test "destructuring in function definition", ->
  (([{ a: [b], c }]...) ->
    eq 1, b
    eq 2, c
  ) a: [1], c: 2

  (([{ a: [b], c }]...) ->
    eq 1, b
    eq 2, c
  ) a: [1], c: 2

  context = {}
  (([{ a: [b, c = 2], @d, e = 4 }]...) ->
    eq 1, b
    eq 2, c
    eq @d, 3
    eq context.d, 3
    eq e, 4
  ).call context, a: [1], d: 3

  (({ a: aa = 1, b: bb = 2 }) ->
    eq 5, aa
    eq 2, bb
  ) a: 5

  ajax = (
    url
    { async = true, beforeSend = ->, cache = true, method = "get", data = {} }
  ) ->
    { url, async, beforeSend, cache, method, data }

  fn = ->
  deepEqual(
    ajax "/home", beforeSend: fn, method: "post"
    url: "/home"
    async: true
    beforeSend: fn
    cache: true
    method: "post"
    data: {}
  )

test "#4005: \`([a = {}]..., b) ->\` weirdness", ->
  fn = ([a = {}]..., b) -> [a, b]
  deepEqual fn(5), [{}, 5]

  fn = ([a = {}]..., b) -> [a, b]
  deepEqual fn(5), [{}, 5]

test "default values", ->
  nonceA = {}
  nonceB = {}
  a = (_, _1, arg = nonceA) -> arg
  eq nonceA, a()
  eq nonceA, a 0
  eq nonceB, a 0, 0, nonceB
  eq nonceA, a 0, 0, undefined
  eq null, a 0, 0, null
  eq false, a 0, 0, false
  eq nonceB, a undefined, undefined, nonceB, undefined
  b = (_, arg = nonceA, _1, _2) -> arg
  eq nonceA, b()
  eq nonceA, b 0
  eq nonceB, b 0, nonceB
  eq nonceA, b 0, undefined
  eq null, b 0, null
  eq false, b 0, false
  eq nonceB, b undefined, nonceB, undefined
  c = (arg = nonceA, _, _1) -> arg
  eq nonceA, c()
  eq 0, c 0
  eq nonceB, c nonceB
  eq nonceA, c undefined
  eq null, c null
  eq false, c false
  eq nonceB, c nonceB, undefined, undefined

test "default values with @-parameters", ->
  a = {}
  b = {}
  obj = f: (q = a, @p = b) -> q
  eq a, obj.f()
  eq b, obj.p

test "default values with splatted arguments", ->
  withSplats = (a = 2, b..., c = 3, d = 5) -> a * (b.length + 1) * c * d
  eq 30, withSplats()
  eq 15, withSplats 1
  eq 5, withSplats 1, 1
  eq 1, withSplats 1, 1, 1
  eq 2, withSplats 1, 1, 1, 1

  withSplats = (a = 2, b..., c = 3, d = 5) -> a * (b.length + 1) * c * d
  eq 30, withSplats()
  eq 15, withSplats 1
  eq 5, withSplats 1, 1
  eq 1, withSplats 1, 1, 1
  eq 2, withSplats 1, 1, 1, 1

test "#156: parameter lists with expansion", ->
  expandArguments = (first, ..., lastButOne, last) ->
    eq 1, first
    eq 4, lastButOne
    last
  eq 5, expandArguments 1, 2, 3, 4, 5

  throws(
    (-> CoffeeScript.compile "(..., a, b...) ->")
    null
    "prohibit expansion and a splat"
  )
  throws (-> CoffeeScript.compile "(...) ->"), null, "prohibit lone expansion"

test "#156: parameter lists with expansion in array destructuring", ->
  expandArray = (..., [..., last]) -> last
  eq 3, expandArray 1, 2, 3, [1, 2, 3]

test "#3502: variable definitions and expansion", ->
  a = b = 0
  f = (a, ..., b) -> [a, b]
  arrayEq [1, 5], f 1, 2, 3, 4, 5
  eq 0, a
  eq 0, b

test "variable definitions and splat", ->
  a = b = 0
  f = (a, middle..., b) -> [a, middle, b]
  arrayEq [1, [2, 3, 4], 5], f 1, 2, 3, 4, 5
  eq 0, a
  eq 0, b

  f = (a, middle..., b) -> [a, middle, b]
  arrayEq [1, [2, 3, 4], 5], f 1, 2, 3, 4, 5
  eq 0, a
  eq 0, b

test "default values with function calls", ->
  doesNotThrow -> CoffeeScript.compile "(x = f()) ->"

(x = f()) ->

test "arguments vs parameters", ->
  doesNotThrow -> CoffeeScript.compile "f(x) ->"
  f = (g) -> g()
  eq 5, f (x) -> 5

f(x) ->

test "reserved keyword as parameters", ->
  f = (_case, @case) -> [_case, @case]
  [a, b] = f 1, 2
  eq 1, a
  eq 2, b

  f = (@case, _case...) -> [@case, _case...]
  [a, b, c] = f 1, 2, 3
  eq 1, a
  eq 2, b
  eq 3, c

test "reserved keyword at-splat", ->
  f = (@case...) -> @case
  [a, b] = f 1, 2
  eq 1, a
  eq 2, b

  f = (@case...) -> @case
  [a, b] = f 1, 2
  eq 1, a
  eq 2, b

test "#1574: Destructuring and a parameter named _arg", ->
  f = ({ a, b }, _arg, _arg1) -> [a, b, _arg, _arg1]
  arrayEq(
    [1, 2, 3, 4]
    f
      a: 1
      b: 2
    ,
      3
      4
  )

test "#1844: bound functions in nested comprehensions causing empty var statements", ->
  a = ((=>) for a in [0] for b in [0])
  eq 1, a.length

test "#1859: inline function bodies shouldn't modify prior postfix ifs", ->
  list = [1, 2, 3]
  return if list.some((x) -> x is 2)
  ok no

test "#2258: allow whitespace-style parameter lists in function definitions", ->
  func = (a, b, c) -> c
  eq func(1, 2, 3), 3

  func = (a, b, c) -> b
  eq func(1, 2, 3), 2

test "#2621: fancy destructuring in parameter lists", ->
  func = ({ prop1: { key1 }, prop2: { key2, key3: [a, b, c] } }) ->
    eq key2, "key2"
    eq a, "a"

  func
    prop1: key1: "key1"
    prop2:
      key2: "key2"
      key3: ["a", "b", "c"]

test "#1435 Indented property access", ->
  rec = -> rec: rec

  eq(
    1
    do ->
      rec().rec ->
        rec()
          .rec -> rec.rec()
          .rec()
      1
  )

test "#1038 Optimize trailing return statements", ->
  compile = (code) ->
    CoffeeScript.compile code, bare: yes
      .trim()
      .replace /\\s+/g, " "

  eq "(function() {});", compile "->"
  eq "(function() {});", compile "-> return"
  eq "(function() { return void 0; });", compile "-> undefined"
  eq "(function() { return void 0; });", compile "-> return undefined"
  eq(
    "(function() { foo(); });"
    compile """
                                                 ->
                                                   foo()
                                                   return
                                                 """
  )

test "#4406 Destructured parameter default evaluation order with incrementing variable", ->
  i = 0
  f = ({ a = ++i }, b = ++i) -> [a, b]
  arrayEq f({}), [1, 2]

test "#4406 Destructured parameter default evaluation order with generator function", ->
  current = 0
  next = -> ++current
  foo = ({ a = next() }, b = next()) -> [a, b]
  arrayEq foo({}), [1, 2]

test "Destructured parameter with default value, that itself has a default value", ->
  draw = (
    { size = "big", coords = { x: 0, y: 0 }, radius = 25 } = {}
  ) -> "#{size}-#{coords.x}-#{coords.y}-#{radius}"
  output =
    draw
      coords:
        x: 18
        y: 30
      radius: 30
  eq output, "big-18-30-30"

test "#4566: destructuring with nested default values", ->
  f = ({ a: { b = 1 } }) -> b
  eq 2, f a: b: 2

test "#1043: comma after function glyph", ->
  x = (a = ->, b = 2) -> a()
  eq x(), undefined

  f = (a) -> a()
  g = f (->), 2
  eq g, undefined
  h = f (=>), 2
  eq h, undefined

test "#3845/#3446: chain after function glyph", ->
  angular = module: -> controller: -> controller: ->

  eq(
    undefined
    angular
      .module "foo"
      .controller "EmailLoginCtrl", ->
      .controller "EmailSignupCtrl", ->
  )

  beforeEach = (f) -> f()
  getPromise = -> then: -> catch: ->

  eq(
    undefined
    beforeEach ->
      getPromise()
        .then (@result) =>
        .catch (@error) =>
  )

  doThing = -> then: -> catch: (f) -> f()
  handleError = -> 3
  eq(
    3
    doThing()
      .then (@result) =>
      .catch handleError
  )

test "#4413: expressions in function parameters that create generated variables have those variables declared correctly", ->
  "use strict"
  foo = -> null
  bar = -> 33
  f = (a = foo() ? bar()) -> a
  g = (a = foo() ? bar()) -> a + 1
  eq f(), 33
  eq g(), 34

test "#4657: destructured array param declarations", ->
  a = 1
  b = 2
  f = ([a..., b]) ->
  f [3, 4, 5]
  eq a, 1
  eq b, 2

test "#4657: destructured array parameters", ->
  f = ([a..., b]) -> { a, b }
  result = f [1, 2, 3, 4]
  arrayEq result.a, [1, 2, 3]
  eq result.b, 4

`;

exports[`javascript_literals.coffee 1`] = `
# JavaScript Literals
# -------------------

test "inline JavaScript is evaluated", ->
  eq '\\\\\`', \`
    // Inline JS
    "\\\\\\\\\\\`"
  \`

test "escaped backticks are output correctly", ->
  \`var a = \\\`2 + 2 = \${4}\\\`\`
  eq a, '2 + 2 = 4'

test "backslashes before a newline don’t break JavaScript blocks", ->
  \`var a = \\\`To be, or not\\\\
  to be.\\\`\`
  eq a, '''
  To be, or not\\\\
    to be.'''

test "block inline JavaScript is evaluated", ->
  \`\`\`
  var a = 1;
  var b = 2;
  \`\`\`
  c = 3
  \`\`\`var d = 4;\`\`\`
  eq a + b + c + d, 10

test "block inline JavaScript containing backticks", ->
  \`\`\`
  // This is a comment with \`backticks\`
  var a = 42;
  var b = \`foo \${'bar'}\`;
  var c = 3;
  var d = 'foo\`bar\`';
  \`\`\`
  eq a + c, 45
  eq b, 'foo bar'
  eq d, 'foo\`bar\`'

test "block JavaScript can end with an escaped backtick character", ->
  \`\`\`var a = \\\`hello\\\`\`\`\`
  \`\`\`
  var b = \\\`world\${'!'}\\\`\`\`\`
  eq a, 'hello'
  eq b, 'world!'

test "JavaScript block only escapes backslashes followed by backticks", ->
  eq \`'\\\\\\n'\`, '\\\\\\n'

test "escaped JavaScript blocks speed round", ->
  # The following has escaped backslashes because they’re required in strings, but the intent is this:
  # \`hello\`                                       → hello;
  # \`\\\`hello\\\`\`                                   → \`hello\`;
  # \`\\\`Escaping backticks in JS: \\\\\\\`hello\\\\\\\`\\\`\` → \`Escaping backticks in JS: \\\`hello\\\`\`;
  # \`Single backslash: \\ \`                        → Single backslash: \\ ;
  # \`Double backslash: \\\\ \`                       → Double backslash: \\\\ ;
  # \`Single backslash at EOS: \\\\\`                 → Single backslash at EOS: \\;
  # \`Double backslash at EOS: \\\\\\\\\`               → Double backslash at EOS: \\\\;
  for [input, output] in [
    ['\`hello\`',                                               'hello;']
    ['\`\\\\\`hello\\\\\`\`',                                         '\`hello\`;']
    ['\`\\\\\`Escaping backticks in JS: \\\\\\\\\\\\\`hello\\\\\\\\\\\\\`\\\\\`\`', '\`Escaping backticks in JS: \\\\\`hello\\\\\`\`;']
    ['\`"Single backslash: \\\\ "\`',                             '"Single backslash: \\\\ ";']
    ['\`"Double backslash: \\\\\\\\ "\`',                           '"Double backslash: \\\\\\\\ ";']
    # ['\`Single backslash at EOS: \\\\\\\\\`',                       'Single backslash at EOS: \\\\;']
    # ['\`Double backslash at EOS: \\\\\\\\\\\\\\\\\`',                   'Double backslash at EOS: \\\\\\\\;']
  ]
    eqJS input, output
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
test "inline JavaScript is evaluated", ->
  eq "\\\\\`", \`
    // Inline JS
    "\\\\\\\\\\\`"
  \`

test "escaped backticks are output correctly", ->
  \`var a = \\\`2 + 2 = \${4}\\\`\`
  eq a, "2 + 2 = 4"

test "backslashes before a newline don’t break JavaScript blocks", ->
  \`var a = \\\`To be, or not\\\\
  to be.\\\`\`
  eq(
    a
    '''
  To be, or not\\\\
    to be.'''
  )

test "block inline JavaScript is evaluated", ->
  \`\`\`
  var a = 1;
  var b = 2;
  \`\`\`
  c = 3
  \`\`\`var d = 4;\`\`\`
  eq a + b + c + d, 10

test "block inline JavaScript containing backticks", ->
  \`\`\`
  // This is a comment with \`backticks\`
  var a = 42;
  var b = \`foo \${'bar'}\`;
  var c = 3;
  var d = 'foo\`bar\`';
  \`\`\`
  eq a + c, 45
  eq b, "foo bar"
  eq d, "foo\`bar\`"

test "block JavaScript can end with an escaped backtick character", ->
  \`\`\`var a = \\\`hello\\\`\`\`\`
  \`\`\`
  var b = \\\`world\${'!'}\\\`\`\`\`
  eq a, "hello"
  eq b, "world!"

test "JavaScript block only escapes backslashes followed by backticks", ->
  eq \`'\\\\\\n'\`, "\\\\\\n"

test "escaped JavaScript blocks speed round", ->
  for [input, output] in [
    ["\`hello\`", "hello;"]
    ["\`\\\\\`hello\\\\\`\`", "\`hello\`;"]
    [
      "\`\\\\\`Escaping backticks in JS: \\\\\\\\\\\\\`hello\\\\\\\\\\\\\`\\\\\`\`"
      "\`Escaping backticks in JS: \\\\\`hello\\\\\`\`;"
    ]
    ['\`"Single backslash: \\\\ "\`', '"Single backslash: \\\\ ";']
    ['\`"Double backslash: \\\\\\\\ "\`', '"Double backslash: \\\\\\\\ ";']
  ]
    eqJS input, output

`;

exports[`numbers.coffee 1`] = `
# Number Literals
# ---------------

# * Decimal Integer Literals
# * Octal Integer Literals
# * Hexadecimal Integer Literals
# * Scientific Notation Integer Literals
# * Scientific Notation Non-Integer Literals
# * Non-Integer Literals
# * Binary Integer Literals


# Binary Integer Literals
# Binary notation is understood as would be decimal notation.

test "Parser recognises binary numbers", ->
  eq 4, 0b100

# Decimal Integer Literals

test "call methods directly on numbers", ->
  eq 4, 4.valueOf()
  eq '11', 4.toString 3

eq -1, 3 -4

#764: Numbers should be indexable
eq Number::toString, 42['toString']

eq Number::toString, 42.toString

eq Number::toString, 2e308['toString'] # Infinity


# Non-Integer Literals

# Decimal number literals.
value = .25 + .75
ok value is 1
value = 0.0 + -.25 - -.75 + 0.0
ok value is 0.5

#764: Numbers should be indexable
eq Number::toString,   4['toString']
eq Number::toString, 4.2['toString']
eq Number::toString, .42['toString']
eq Number::toString, (4)['toString']

eq Number::toString,   4.toString
eq Number::toString, 4.2.toString
eq Number::toString, .42.toString
eq Number::toString, (4).toString

test '#1168: leading floating point suppresses newline', ->
  eq 1, do ->
    1
    .5 + 0.5

test "Python-style octal literal notation '0o777'", ->
  eq 511, 0o777
  eq 1, 0o1
  eq 1, 0o00001
  eq parseInt('0777', 8), 0o777
  eq '777', 0o777.toString 8
  eq 4, 0o4.valueOf()
  eq Number::toString, 0o777['toString']
  eq Number::toString, 0o777.toString

test "#2060: Disallow uppercase radix prefixes and exponential notation", ->
  for char in ['b', 'o', 'x', 'e']
    program = "0#{char}0"
    doesNotThrow -> CoffeeScript.compile program, bare: yes
    throws -> CoffeeScript.compile program.toUpperCase(), bare: yes

test "#2224: hex literals with 0b or B or E", ->
  eq 176, 0x0b0
  eq 177, 0x0B1
  eq 225, 0xE1

test "Infinity", ->
  eq Infinity, CoffeeScript.eval "0b#{Array(1024 + 1).join('1')}"
  eq Infinity, CoffeeScript.eval "0o#{Array(342 + 1).join('7')}"
  eq Infinity, CoffeeScript.eval "0x#{Array(256 + 1).join('f')}"
  eq Infinity, CoffeeScript.eval Array(500 + 1).join('9')
  eq Infinity, 2e308

test "NaN", ->
  ok isNaN 1/NaN
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
test "Parser recognises binary numbers", -> eq 4, 0b100

test "call methods directly on numbers", ->
  eq 4, 4.valueOf()
  eq "11", 4.toString 3

eq -1, 3 - 4

eq Number::toString, 42["toString"]

eq Number::toString, 42.toString

eq Number::toString, Infinity["toString"]
value = 0.25 + 0.75
ok value is 1
value = 0.0 + -0.25 - -0.75 + 0.0
ok value is 0.5

eq Number::toString, 4["toString"]
eq Number::toString, 4.2["toString"]
eq Number::toString, 0.42["toString"]
eq Number::toString, 4["toString"]

eq Number::toString, 4.toString
eq Number::toString, 4.2.toString
eq Number::toString, 0.42.toString
eq Number::toString, 4.toString

test "#1168: leading floating point suppresses newline", ->
  eq(
    1
    do ->
      1
      0.5 + 0.5
  )

test "Python-style octal literal notation '0o777'", ->
  eq 511, 0o777
  eq 1, 0o1
  eq 1, 0o00001
  eq parseInt("0777", 8), 0o777
  eq "777", 0o777.toString 8
  eq 4, 0o4.valueOf()
  eq Number::toString, 0o777["toString"]
  eq Number::toString, 0o777.toString

test "#2060: Disallow uppercase radix prefixes and exponential notation", ->
  for char in ["b", "o", "x", "e"]
    program = "0#{char}0"
    doesNotThrow -> CoffeeScript.compile program, bare: yes
    throws -> CoffeeScript.compile program.toUpperCase(), bare: yes

test "#2224: hex literals with 0b or B or E", ->
  eq 176, 0x0b0
  eq 177, 0x0b1
  eq 225, 0xe1

test "Infinity", ->
  eq Infinity, CoffeeScript.eval "0b#{Array(1024 + 1).join "1"}"
  eq Infinity, CoffeeScript.eval "0o#{Array(342 + 1).join "7"}"
  eq Infinity, CoffeeScript.eval "0x#{Array(256 + 1).join "f"}"
  eq Infinity, CoffeeScript.eval Array(500 + 1).join "9"
  eq Infinity, Infinity

test "NaN", -> ok isNaN 1 / NaN

`;

exports[`operators.coffee 1`] = `
# Operators
# ---------

# * Operators
# * Existential Operator (Binary)
# * Existential Operator (Unary)
# * Aliased Operators
# * [not] in/of
# * Chained Comparison

test "binary (2-ary) math operators do not require spaces", ->
  a = 1
  b = -1
  eq +1, a*-b
  eq -1, a*+b
  eq +1, a/-b
  eq -1, a/+b

test "operators should respect new lines as spaced", ->
  a = 123 +
  456
  eq 579, a

  b = "1#{2}3" +
  "456"
  eq '123456', b

test "multiple operators should space themselves", ->
  eq (+ +1), (- -1)

test "compound operators on successive lines", ->
  a = 1
  a +=
  1
  eq a, 2

test "bitwise operators", ->
  eq  2, (10 &   3)
  eq 11, (10 |   3)
  eq  9, (10 ^   3)
  eq 80, (10 <<  3)
  eq  1, (10 >>  3)
  eq  1, (10 >>> 3)
  num = 10; eq  2, (num &=   3)
  num = 10; eq 11, (num |=   3)
  num = 10; eq  9, (num ^=   3)
  num = 10; eq 80, (num <<=  3)
  num = 10; eq  1, (num >>=  3)
  num = 10; eq  1, (num >>>= 3)

test "\`instanceof\`", ->
  ok new String instanceof String
  ok new Boolean instanceof Boolean
  # \`instanceof\` supports negation by prefixing the operator with \`not\`
  ok new Number not instanceof String
  ok new Array not instanceof Boolean

test "use \`::\` operator on keywords \`this\` and \`@\`", ->
  nonce = {}
  obj =
    withAt:   -> @::prop
    withThis: -> this::prop
  obj.prototype = prop: nonce
  eq nonce, obj.withAt()
  eq nonce, obj.withThis()


# Existential Operator (Binary)

test "binary existential operator", ->
  nonce = {}

  b = a ? nonce
  eq nonce, b

  a = null
  b = undefined
  b = a ? nonce
  eq nonce, b

  a = false
  b = a ? nonce
  eq false, b

  a = 0
  b = a ? nonce
  eq 0, b

test "binary existential operator conditionally evaluates second operand", ->
  i = 1
  func = -> i -= 1
  result = func() ? func()
  eq result, 0

test "binary existential operator with negative number", ->
  a = null ? - 1
  eq -1, a


# Existential Operator (Unary)

test "postfix existential operator", ->
  ok (if nonexistent? then false else true)
  defined = true
  ok defined?
  defined = false
  ok defined?

test "postfix existential operator only evaluates its operand once", ->
  semaphore = 0
  fn = ->
    ok false if semaphore
    ++semaphore
  ok(if fn()? then true else false)

test "negated postfix existential operator", ->
  ok !nothing?.value

test "postfix existential operator on expressions", ->
  eq true, (1 or 0)?, true


# \`is\`,\`isnt\`,\`==\`,\`!=\`

test "\`==\` and \`is\` should be interchangeable", ->
  a = b = 1
  ok a is 1 and b == 1
  ok a == b
  ok a is b

test "\`!=\` and \`isnt\` should be interchangeable", ->
  a = 0
  b = 1
  ok a isnt 1 and b != 0
  ok a != b
  ok a isnt b


# [not] in/of

# - \`in\` should check if an array contains a value using \`indexOf\`
# - \`of\` should check if a property is defined on an object using \`in\`
test "in, of", ->
  arr = [1]
  ok 0 of arr
  ok 1 in arr
  # prefixing \`not\` to \`in and \`of\` should negate them
  ok 1 not of arr
  ok 0 not in arr

test "\`in\` should be able to operate on an array literal", ->
  ok 2 in [0, 1, 2, 3]
  ok 4 not in [0, 1, 2, 3]
  arr = [0, 1, 2, 3]
  ok 2 in arr
  ok 4 not in arr
  # should cache the value used to test the array
  arr = [0]
  val = 0
  ok val++ in arr
  ok val++ not in arr
  val = 0
  ok val++ of arr
  ok val++ not of arr

test "\`of\` and \`in\` should be able to operate on instance variables", ->
  obj = {
    list: [2,3]
    in_list: (value) -> value in @list
    not_in_list: (value) -> value not in @list
    of_list: (value) -> value of @list
    not_of_list: (value) -> value not of @list
  }
  ok obj.in_list 3
  ok obj.not_in_list 1
  ok obj.of_list 0
  ok obj.not_of_list 2

test "#???: \`in\` with cache and \`__indexOf\` should work in argument lists", ->
  eq 1, [Object() in Array()].length

test "#737: \`in\` should have higher precedence than logical operators", ->
  eq 1, 1 in [1] and 1

test "#768: \`in\` should preserve evaluation order", ->
  share = 0
  a = -> share++ if share is 0
  b = -> share++ if share is 1
  c = -> share++ if share is 2
  ok a() not in [b(),c()]
  eq 3, share

test "#1099: empty array after \`in\` should compile to \`false\`", ->
  eq 1, [5 in []].length
  eq false, do -> return 0 in []

test "#1354: optimized \`in\` checks should not happen when splats are present", ->
  a = [6, 9]
  eq 9 in [3, a...], true

test "#1100: precedence in or-test compilation of \`in\`", ->
  ok 0 in [1 and 0]
  ok 0 in [1, 1 and 0]
  ok not (0 in [1, 0 or 1])

test "#1630: \`in\` should check \`hasOwnProperty\`", ->
  ok undefined not in length: 1

test "#1714: lexer bug with raw range \`for\` followed by \`in\`", ->
  0 for [1..2]
  ok not ('a' in ['b'])

  0 for [1..2]; ok not ('a' in ['b'])

  0 for [1..10] # comment ending
  ok not ('a' in ['b'])

  # lexer state (specifically @seenFor) should be reset before each compilation
  CoffeeScript.compile "0 for [1..2]"
  CoffeeScript.compile "'a' in ['b']"

test "#1099: statically determined \`not in []\` reporting incorrect result", ->
  ok 0 not in []

test "#1099: make sure expression tested gets evaluted when array is empty", ->
  a = 0
  (do -> a = 1) in []
  eq a, 1

# Chained Comparison

test "chainable operators", ->
  ok 100 > 10 > 1 > 0 > -1
  ok -1 < 0 < 1 < 10 < 100

test "\`is\` and \`isnt\` may be chained", ->
  ok true is not false is true is not false
  ok 0 is 0 isnt 1 is 1

test "different comparison operators (\`>\`,\`<\`,\`is\`,etc.) may be combined", ->
  ok 1 < 2 > 1
  ok 10 < 20 > 2+3 is 5

test "some chainable operators can be negated by \`unless\`", ->
  ok (true unless 0==10!=100)

test "operator precedence: \`|\` lower than \`<\`", ->
  eq 1, 1 | 2 < 3 < 4

test "preserve references", ->
  a = b = c = 1
  # \`a == b <= c\` should become \`a === b && b <= c\`
  # (this test does not seem to test for this)
  ok a == b <= c

test "chained operations should evaluate each value only once", ->
  a = 0
  ok 1 > a++ < 1

test "#891: incorrect inversion of chained comparisons", ->
  ok (true unless 0 > 1 > 2)
  ok (true unless (this.NaN = 0/0) < 0/0 < this.NaN)

test "#1234: Applying a splat to :: applies the splat to the wrong object", ->
  nonce = {}
  class C
    method: -> @nonce
    nonce: nonce

  arr = []
  eq nonce, C::method arr... # should be applied to \`C::\`

test "#1102: String literal prevents line continuation", ->
  eq "': '", '' +
     "': '"

test "#1703, ---x is invalid JS", ->
  x = 2
  eq (- --x), -1

test "Regression with implicit calls against an indented assignment", ->
  eq 1, a =
    1

  eq a, 1

test "#2155 ... conditional assignment to a closure", ->
  x = null
  func = -> x ?= (-> if true then 'hi')
  func()
  eq x(), 'hi'

test "#2197: Existential existential double trouble", ->
  counter = 0
  func = -> counter++
  func()? ? 100
  eq counter, 1

test "#2567: Optimization of negated existential produces correct result", ->
  a = 1
  ok !(!a?)
  ok !b?

test "#2508: Existential access of the prototype", ->
  eq NonExistent?::nothing, undefined
  ok Object?::toString

test "floor division operator", ->
  eq 2, 7 // 3
  eq -3, -7 // 3
  eq NaN, 0 // 0

test "floor division operator compound assignment", ->
  a = 7
  a //= 1 + 1
  eq 3, a

test "modulo operator", ->
  check = (a, b, expected) ->
    eq expected, a %% b, "expected #{a} %%%% #{b} to be #{expected}"
  check 0, 1, 0
  check 0, -1, -0
  check 1, 0, NaN
  check 1, 2, 1
  check 1, -2, -1
  check 1, 3, 1
  check 2, 3, 2
  check 3, 3, 0
  check 4, 3, 1
  check -1, 3, 2
  check -2, 3, 1
  check -3, 3, 0
  check -4, 3, 2
  check 5.5, 2.5, 0.5
  check -5.5, 2.5, 2.0

test "modulo operator compound assignment", ->
  a = -2
  a %%= 5
  eq 3, a

test "modulo operator converts arguments to numbers", ->
  eq 1, 1 %% '42'
  eq 1, '1' %% 42
  eq 1, '1' %% '42'

test "#3361: Modulo operator coerces right operand once", ->
  count = 0
  res = 42 %% valueOf: -> count += 1
  eq 1, count
  eq 0, res

test "#3363: Modulo operator coercing order", ->
  count = 2
  a = valueOf: -> count *= 2
  b = valueOf: -> count += 1
  eq 4, a %% b
  eq 5, count

test "#3598: Unary + and - coerce the operand once when it is an identifier", ->
  # Unary + and - do not generate \`_ref\`s when the operand is a number, for
  # readability. To make sure that they do when the operand is an identifier,
  # test that they are consistent with another unary operator as well as another
  # complex expression.
  # Tip: Making one of the tests temporarily fail lets you easily inspect the
  # compiled JavaScript.

  assertOneCoercion = (fn) ->
    count = 0
    value = valueOf: -> count++; 1
    fn value
    eq 1, count

  eq 1, 1 ? 0
  eq 1, +1 ? 0
  eq -1, -1 ? 0
  assertOneCoercion (a) ->
    eq 1, +a ? 0
  assertOneCoercion (a) ->
    eq -1, -a ? 0
  assertOneCoercion (a) ->
    eq -2, ~a ? 0
  assertOneCoercion (a) ->
    eq 0.5, a / 2 ? 0

  ok -2 <= 1 < 2
  ok -2 <= +1 < 2
  ok -2 <= -1 < 2
  assertOneCoercion (a) ->
    ok -2 <= +a < 2
  assertOneCoercion (a) ->
    ok -2 <= -a < 2
  assertOneCoercion (a) ->
    ok -2 <= ~a < 2
  assertOneCoercion (a) ->
    ok -2 <= a / 2 < 2

  arrayEq [0], (n for n in [0] by 1)
  arrayEq [0], (n for n in [0] by +1)
  arrayEq [0], (n for n in [0] by -1)
  assertOneCoercion (a) ->
    arrayEq [0], (n for n in [0] by +a)
  assertOneCoercion (a) ->
    arrayEq [0], (n for n in [0] by -a)
  assertOneCoercion (a) ->
    arrayEq [0], (n for n in [0] by ~a)
  assertOneCoercion (a) ->
    arrayEq [0], (n for n in [0] by a * 2 / 2)

  ok 1 in [0, 1]
  ok +1 in [0, 1]
  ok -1 in [0, -1]
  assertOneCoercion (a) ->
    ok +a in [0, 1]
  assertOneCoercion (a) ->
    ok -a in [0, -1]
  assertOneCoercion (a) ->
    ok ~a in [0, -2]
  assertOneCoercion (a) ->
    ok a / 2 in [0, 0.5]

test "'new' target", ->
  nonce = {}
  ctor  = -> nonce

  eq (new ctor), nonce
  eq (new ctor()), nonce

  ok new class

  ctor  = class
  ok (new ctor) instanceof ctor
  ok (new ctor()) instanceof ctor

  # Force an executable class body
  ctor  = class then a = 1
  ok (new ctor) instanceof ctor

  get   = -> ctor
  ok (new get()) not instanceof ctor
  ok (new (get())()) instanceof ctor

  # classes must be called with \`new\`. In this case \`new\` applies to \`get\` only
  throws -> new get()()
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
test "binary (2-ary) math operators do not require spaces", ->
  a = 1
  b = -1
  eq +1, a * -b
  eq -1, a * +b
  eq +1, a / -b
  eq -1, a / +b

test "operators should respect new lines as spaced", ->
  a = 123 + 456
  eq 579, a

  b = "1#{2}3" + "456"
  eq "123456", b

test "multiple operators should space themselves", -> eq +(+1), -(-1)

test "compound operators on successive lines", ->
  a = 1
  a += 1
  eq a, 2

test "bitwise operators", ->
  eq 2, 10 & 3
  eq 11, 10 | 3
  eq 9, 10 ^ 3
  eq 80, 10 << 3
  eq 1, 10 >> 3
  eq 1, 10 >>> 3
  num = 10
  eq 2, num &= 3
  num = 10
  eq 11, num |= 3
  num = 10
  eq 9, num ^= 3
  num = 10
  eq 80, num <<= 3
  num = 10
  eq 1, num >>= 3
  num = 10
  eq 1, num >>>= 3

test "\`instanceof\`", ->
  ok new String() instanceof String
  ok new Boolean() instanceof Boolean
  ok new Number() not instanceof String
  ok new Array() not instanceof Boolean

test "use \`::\` operator on keywords \`this\` and \`@\`", ->
  nonce = {}
  obj = withAt: -> @::prop, withThis: -> @::prop
  obj:: = prop: nonce
  eq nonce, obj.withAt()
  eq nonce, obj.withThis()

test "binary existential operator", ->
  nonce = {}

  b = a ? nonce
  eq nonce, b

  a = null
  b = undefined
  b = a ? nonce
  eq nonce, b

  a = false
  b = a ? nonce
  eq false, b

  a = 0
  b = a ? nonce
  eq 0, b

test "binary existential operator conditionally evaluates second operand", ->
  i = 1
  func = -> i -= 1
  result = func() ? func()
  eq result, 0

test "binary existential operator with negative number", ->
  a = null ? -1
  eq -1, a

test "postfix existential operator", ->
  ok(
    if nonexistent?
      false
    else
      true
  )
  defined = true
  ok defined?
  defined = false
  ok defined?

test "postfix existential operator only evaluates its operand once", ->
  semaphore = 0
  fn = ->
    ok false if semaphore
    ++semaphore
  ok(
    if fn()?
      true
    else
      false
  )

test "negated postfix existential operator", -> ok !nothing?.value

test "postfix existential operator on expressions", -> eq true, (1 or 0)?, true

test "\`==\` and \`is\` should be interchangeable", ->
  a = b = 1
  ok a is 1 and b == 1
  ok a == b
  ok a is b

test "\`!=\` and \`isnt\` should be interchangeable", ->
  a = 0
  b = 1
  ok a isnt 1 and b != 0
  ok a != b
  ok a isnt b

test "in, of", ->
  arr = [1]
  ok 0 of arr
  ok 1 in arr
  ok 1 not of arr
  ok 0 not in arr

test "\`in\` should be able to operate on an array literal", ->
  ok 2 in [0, 1, 2, 3]
  ok 4 not in [0, 1, 2, 3]
  arr = [0, 1, 2, 3]
  ok 2 in arr
  ok 4 not in arr
  arr = [0]
  val = 0
  ok val++ in arr
  ok val++ not in arr
  val = 0
  ok val++ of arr
  ok val++ not of arr

test "\`of\` and \`in\` should be able to operate on instance variables", ->
  obj =
    list: [2, 3]
    in_list: (value) -> value in @list
    not_in_list: (value) -> value not in @list
    of_list: (value) -> value of @list
    not_of_list: (value) -> value not of @list
  ok obj.in_list 3
  ok obj.not_in_list 1
  ok obj.of_list 0
  ok obj.not_of_list 2

test "#???: \`in\` with cache and \`__indexOf\` should work in argument lists", ->
  eq 1, [Object() in Array()].length

test "#737: \`in\` should have higher precedence than logical operators", ->
  eq 1, 1 in [1] and 1

test "#768: \`in\` should preserve evaluation order", ->
  share = 0
  a = -> share++ if share is 0
  b = -> share++ if share is 1
  c = -> share++ if share is 2
  ok a() not in [b(), c()]
  eq 3, share

test "#1099: empty array after \`in\` should compile to \`false\`", ->
  eq 1, [5 in []].length
  eq(
    false
    do ->
      return 0 in []
  )

test "#1354: optimized \`in\` checks should not happen when splats are present", ->
  a = [6, 9]
  eq 9 in [3, a...], true

test "#1100: precedence in or-test compilation of \`in\`", ->
  ok 0 in [1 and 0]
  ok 0 in [1, 1 and 0]
  ok not (0 in [1, 0 or 1])

test "#1630: \`in\` should check \`hasOwnProperty\`", ->
  ok undefined not in length: 1

test "#1714: lexer bug with raw range \`for\` followed by \`in\`", ->
  0 for [1..2]
  ok not ("a" in ["b"])

  0 for [1..2]
  ok not ("a" in ["b"])

  0 for [1..10]
  ok not ("a" in ["b"])

  CoffeeScript.compile "0 for [1..2]"
  CoffeeScript.compile "'a' in ['b']"

test "#1099: statically determined \`not in []\` reporting incorrect result", ->
  ok 0 not in []

test "#1099: make sure expression tested gets evaluted when array is empty", ->
  a = 0
  (do ->
    a = 1) in []
  eq a, 1

test "chainable operators", ->
  ok 100 > 10 > 1 > 0 > -1
  ok -1 < 0 < 1 < 10 < 100

test "\`is\` and \`isnt\` may be chained", ->
  ok true is not false is true is not false
  ok 0 is 0 isnt 1 is 1

test "different comparison operators (\`>\`,\`<\`,\`is\`,etc.) may be combined", ->
  ok 1 < 2 > 1
  ok 10 < 20 > 2 + 3 is 5

test "some chainable operators can be negated by \`unless\`", ->
  ok (true unless 0 == 10 != 100)

test "operator precedence: \`|\` lower than \`<\`", -> eq 1, 1 | 2 < 3 < 4

test "preserve references", ->
  a = b = c = 1
  ok (a == b) <= c

test "chained operations should evaluate each value only once", ->
  a = 0
  ok 1 > a++ < 1

test "#891: incorrect inversion of chained comparisons", ->
  ok (true unless 0 > 1 > 2)
  ok (true unless (@NaN = 0 / 0) < 0 / 0 < @NaN)

test "#1234: Applying a splat to :: applies the splat to the wrong object", ->
  nonce = {}
  class C
    method: ->
      @nonce
    nonce: nonce

  arr = []
  eq nonce, C::method arr...
test "#1102: String literal prevents line continuation", ->
  eq "': '", "" + "': '"

test "#1703, ---x is invalid JS", ->
  x = 2
  eq -(--x), -1

test "Regression with implicit calls against an indented assignment", ->
  eq 1, (a = 1)

  eq a, 1

test "#2155 ... conditional assignment to a closure", ->
  x = null
  func = ->
    x ?= ->
      if true
        "hi"
  func()
  eq x(), "hi"

test "#2197: Existential existential double trouble", ->
  counter = 0
  func = -> counter++
  func()? ? 100
  eq counter, 1

test "#2567: Optimization of negated existential produces correct result", ->
  a = 1
  ok !!a?
  ok !b?

test "#2508: Existential access of the prototype", ->
  eq NonExistent?::nothing, undefined
  ok Object?::toString

test "floor division operator", ->
  eq 2, 7 // 3
  eq -3, -7 // 3
  eq NaN, 0 // 0

test "floor division operator compound assignment", ->
  a = 7
  a //= 1 + 1
  eq 3, a

test "modulo operator", ->
  check = (a, b, expected) ->
    eq expected, a %% b, "expected #{a} %%%% #{b} to be #{expected}"
  check 0, 1, 0
  check 0, -1, -0
  check 1, 0, NaN
  check 1, 2, 1
  check 1, -2, -1
  check 1, 3, 1
  check 2, 3, 2
  check 3, 3, 0
  check 4, 3, 1
  check -1, 3, 2
  check -2, 3, 1
  check -3, 3, 0
  check -4, 3, 2
  check 5.5, 2.5, 0.5
  check -5.5, 2.5, 2.0

test "modulo operator compound assignment", ->
  a = -2
  a %%= 5
  eq 3, a

test "modulo operator converts arguments to numbers", ->
  eq 1, 1 %% "42"
  eq 1, "1" %% 42
  eq 1, "1" %% "42"

test "#3361: Modulo operator coerces right operand once", ->
  count = 0
  res = 42 %% valueOf: -> count += 1
  eq 1, count
  eq 0, res

test "#3363: Modulo operator coercing order", ->
  count = 2
  a = valueOf: -> count *= 2
  b = valueOf: -> count += 1
  eq 4, a %% b
  eq 5, count

test "#3598: Unary + and - coerce the operand once when it is an identifier", ->
  assertOneCoercion = (fn) ->
    count = 0
    value =
      valueOf: ->
        count++
        1
    fn value
    eq 1, count

  eq 1, 1 ? 0
  eq 1, +1 ? 0
  eq -1, -1 ? 0
  assertOneCoercion (a) -> eq 1, +a ? 0
  assertOneCoercion (a) -> eq -1, -a ? 0
  assertOneCoercion (a) -> eq -2, ~a ? 0
  assertOneCoercion (a) -> eq 0.5, a / 2 ? 0

  ok -2 <= 1 < 2
  ok -2 <= +1 < 2
  ok -2 <= -1 < 2
  assertOneCoercion (a) -> ok -2 <= +a < 2
  assertOneCoercion (a) -> ok -2 <= -a < 2
  assertOneCoercion (a) -> ok -2 <= ~a < 2
  assertOneCoercion (a) -> ok -2 <= a / 2 < 2

  arrayEq [0], (n for n in [0] by 1)
  arrayEq [0], (n for n in [0] by +1)
  arrayEq [0], (n for n in [0] by -1)
  assertOneCoercion (a) -> arrayEq [0], (n for n in [0] by +a)
  assertOneCoercion (a) -> arrayEq [0], (n for n in [0] by -a)
  assertOneCoercion (a) -> arrayEq [0], (n for n in [0] by ~a)
  assertOneCoercion (a) -> arrayEq [0], (n for n in [0] by (a * 2) / 2)

  ok 1 in [0, 1]
  ok +1 in [0, 1]
  ok -1 in [0, -1]
  assertOneCoercion (a) -> ok +a in [0, 1]
  assertOneCoercion (a) -> ok -a in [0, -1]
  assertOneCoercion (a) -> ok ~a in [0, -2]
  assertOneCoercion (a) -> ok a / 2 in [0, 0.5]

test "'new' target", ->
  nonce = {}
  ctor = -> nonce

  eq new ctor(), nonce
  eq new ctor(), nonce

  ok new class()

  ctor = class
  ok new ctor() instanceof ctor
  ok new ctor() instanceof ctor

  ctor = class
    a = 1
  ok new ctor() instanceof ctor

  get = -> ctor
  ok new get() not instanceof ctor
  ok new (get())() instanceof ctor

  throws -> new get()()

`;

exports[`ranges.coffee 1`] = `
# Range Literals
# --------------

# TODO: add indexing and method invocation tests: [1..4][0] is 1, [0...3].toString()

# shared array
shared = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

test "basic inclusive ranges", ->
  arrayEq [1, 2, 3] , [1..3]
  arrayEq [0, 1, 2] , [0..2]
  arrayEq [0, 1]    , [0..1]
  arrayEq [0]       , [0..0]
  arrayEq [-1]      , [-1..-1]
  arrayEq [-1, 0]   , [-1..0]
  arrayEq [-1, 0, 1], [-1..1]

test "basic exclusive ranges", ->
  arrayEq [1, 2, 3] , [1...4]
  arrayEq [0, 1, 2] , [0...3]
  arrayEq [0, 1]    , [0...2]
  arrayEq [0]       , [0...1]
  arrayEq [-1]      , [-1...0]
  arrayEq [-1, 0]   , [-1...1]
  arrayEq [-1, 0, 1], [-1...2]

  arrayEq [], [1...1]
  arrayEq [], [0...0]
  arrayEq [], [-1...-1]

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  arrayEq [1, 2, 3] , [1 ... 4]
  arrayEq [0, 1, 2] , [0 ... 3]
  arrayEq [0, 1]    , [0 ... 2]
  arrayEq [0]       , [0 ... 1]
  arrayEq [-1]      , [-1 ... 0]
  arrayEq [-1, 0]   , [-1 ... 1]
  arrayEq [-1, 0, 1], [-1 ... 2]

  arrayEq [], [1 ... 1]
  arrayEq [], [0 ... 0]
  arrayEq [], [-1 ... -1]

test "downward ranges", ->
  arrayEq shared, [9..0].reverse()
  arrayEq [5, 4, 3, 2] , [5..2]
  arrayEq [2, 1, 0, -1], [2..-1]

  arrayEq [3, 2, 1]  , [3..1]
  arrayEq [2, 1, 0]  , [2..0]
  arrayEq [1, 0]     , [1..0]
  arrayEq [0]        , [0..0]
  arrayEq [-1]       , [-1..-1]
  arrayEq [0, -1]    , [0..-1]
  arrayEq [1, 0, -1] , [1..-1]
  arrayEq [0, -1, -2], [0..-2]

  arrayEq [4, 3, 2], [4...1]
  arrayEq [3, 2, 1], [3...0]
  arrayEq [2, 1]   , [2...0]
  arrayEq [1]      , [1...0]
  arrayEq []       , [0...0]
  arrayEq []       , [-1...-1]
  arrayEq [0]      , [0...-1]
  arrayEq [0, -1]  , [0...-2]
  arrayEq [1, 0]   , [1...-1]
  arrayEq [2, 1, 0], [2...-1]

test "ranges with variables as enpoints", ->
  [a, b] = [1, 3]
  arrayEq [1, 2, 3], [a..b]
  arrayEq [1, 2]   , [a...b]
  b = -2
  arrayEq [1, 0, -1, -2], [a..b]
  arrayEq [1, 0, -1]    , [a...b]

test "ranges with expressions as endpoints", ->
  [a, b] = [1, 3]
  arrayEq [2, 3, 4, 5, 6], [(a+1)..2*b]
  arrayEq [2, 3, 4, 5]   , [(a+1)...2*b]

  # Should not trigger implicit call, e.g. rest ... => rest(...)
  arrayEq [2, 3, 4, 5]   , [(a+1) ... 2*b]

test "large ranges are generated with looping constructs", ->
  down = [99..0]
  eq 100, (len = down.length)
  eq   0, down[len - 1]

  up = [0...100]
  eq 100, (len = up.length)
  eq  99, up[len - 1]

test "for-from loops over ranges", ->
  array1 = []
  for x from [20..30]
    array1.push(x)
    break if x is 25
  arrayEq array1, [20, 21, 22, 23, 24, 25]

test "for-from comprehensions over ranges", ->
  array1 = (x + 10 for x from [20..25])
  ok array1.join(' ') is '30 31 32 33 34 35'

  array2 = (x for x from [20..30] when x %% 2 == 0)
  ok array2.join(' ') is '20 22 24 26 28 30'

test "#1012 slices with arguments object", ->
  expected = [0..9]
  argsAtStart = (-> [arguments[0]..9]) 0
  arrayEq expected, argsAtStart
  argsAtEnd = (-> [0..arguments[0]]) 9
  arrayEq expected, argsAtEnd
  argsAtBoth = (-> [arguments[0]..arguments[1]]) 0, 9
  arrayEq expected, argsAtBoth

test "#1409: creating large ranges outside of a function body", ->
  CoffeeScript.eval '[0..100]'

test "#2047: Infinite loop possible when \`for\` loop with \`range\` uses variables", ->
  up = 1
  down = -1
  a = 1
  b = 5

  testRange = (arg) ->
    [from, to, step, expectedResult] = arg
    r = (x for x in [from..to] by step)
    arrayEq r, expectedResult

  testData = [
    [1, 5, 1, [1..5]]
    [1, 5, -1, []]
    [1, 5, up, [1..5]]
    [1, 5, down, []]

    [a, 5, 1, [1..5]]
    [a, 5, -1, []]
    [a, 5, up, [1..5]]
    [a, 5, down, []]

    [1, b, 1, [1..5]]
    [1, b, -1, []]
    [1, b, up, [1..5]]
    [1, b, down, []]

    [a, b, 1, [1..5]]
    [a, b, -1, []]
    [a, b, up, [1..5]]
    [a, b, down, []]

    [5, 1, 1, []]
    [5, 1, -1, [5..1]]
    [5, 1, up, []]
    [5, 1, down,  [5..1]]

    [5, a, 1, []]
    [5, a, -1, [5..1]]
    [5, a, up, []]
    [5, a, down, [5..1]]

    [b, 1, 1, []]
    [b, 1, -1, [5..1]]
    [b, 1, up, []]
    [b, 1, down, [5..1]]

    [b, a, 1, []]
    [b, a, -1, [5..1]]
    [b, a, up, []]
    [b, a, down, [5..1]]
  ]

  testRange d for d in testData

test "#2047: from, to and step as variables", ->
  up = 1
  down = -1
  a = 1
  b = 5

  r = (x for x in [a..b] by up)
  arrayEq r, [1..5]

  r = (x for x in [a..b] by down)
  arrayEq r, []

  r = (x for x in [b..a] by up)
  arrayEq r, []

  r = (x for x in [b..a] by down)
  arrayEq r, [5..1]

  a = 1
  b = -1
  step = 0
  r = (x for x in [b..a] by step)
  arrayEq r, []

test "#4884: Range not declaring var for the 'i'", ->
  'use strict'
  [0..21].forEach (idx) ->
    idx + 1

  eq global.i, undefined

test "#4889: \`for\` loop unexpected behavior", ->
  n = 1
  result = []
  for i in [0..n]
    result.push i
    for j in [(i+1)..n]
      result.push j

  arrayEq result, [0,1,1,2,1]

test "#4889: \`for\` loop unexpected behavior with \`by 1\` on second loop", ->
  n = 1
  result = []
  for i in [0..n]
    result.push i
    for j in [(i+1)..n] by 1
      result.push j

  arrayEq result, [0,1,1]

test "countdown example from docs", ->
  countdown = (num for num in [10..1])
  arrayEq countdown, [10,9,8,7,6,5,4,3,2,1]

test "counting up when the range goes down returns an empty array", ->
  countdown = (num for num in [10..1] by 1)
  arrayEq countdown, []

test "counting down when the range goes up returns an empty array", ->
  countup = (num for num in [1..10] by -1)
  arrayEq countup, []

test "counting down by too much returns just the first value", ->
  countdown = (num for num in [10..1] by -100)
  arrayEq countdown, [10]

test "counting up by too much returns just the first value", ->
  countup = (num for num in [1..10] by 100)
  arrayEq countup, [1]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
shared = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

test "basic inclusive ranges", ->
  arrayEq [1, 2, 3], [1..3]
  arrayEq [0, 1, 2], [0..2]
  arrayEq [0, 1], [0..1]
  arrayEq [0], [0..0]
  arrayEq [-1], [-1..-1]
  arrayEq [-1, 0], [-1..0]
  arrayEq [-1, 0, 1], [-1..1]

test "basic exclusive ranges", ->
  arrayEq [1, 2, 3], [1...4]
  arrayEq [0, 1, 2], [0...3]
  arrayEq [0, 1], [0...2]
  arrayEq [0], [0...1]
  arrayEq [-1], [-1...0]
  arrayEq [-1, 0], [-1...1]
  arrayEq [-1, 0, 1], [-1...2]

  arrayEq [], [1...1]
  arrayEq [], [0...0]
  arrayEq [], [-1...-1]

  arrayEq [1, 2, 3], [1...4]
  arrayEq [0, 1, 2], [0...3]
  arrayEq [0, 1], [0...2]
  arrayEq [0], [0...1]
  arrayEq [-1], [-1...0]
  arrayEq [-1, 0], [-1...1]
  arrayEq [-1, 0, 1], [-1...2]

  arrayEq [], [1...1]
  arrayEq [], [0...0]
  arrayEq [], [-1...-1]

test "downward ranges", ->
  arrayEq shared, [9..0].reverse()
  arrayEq [5, 4, 3, 2], [5..2]
  arrayEq [2, 1, 0, -1], [2..-1]

  arrayEq [3, 2, 1], [3..1]
  arrayEq [2, 1, 0], [2..0]
  arrayEq [1, 0], [1..0]
  arrayEq [0], [0..0]
  arrayEq [-1], [-1..-1]
  arrayEq [0, -1], [0..-1]
  arrayEq [1, 0, -1], [1..-1]
  arrayEq [0, -1, -2], [0..-2]

  arrayEq [4, 3, 2], [4...1]
  arrayEq [3, 2, 1], [3...0]
  arrayEq [2, 1], [2...0]
  arrayEq [1], [1...0]
  arrayEq [], [0...0]
  arrayEq [], [-1...-1]
  arrayEq [0], [0...-1]
  arrayEq [0, -1], [0...-2]
  arrayEq [1, 0], [1...-1]
  arrayEq [2, 1, 0], [2...-1]

test "ranges with variables as enpoints", ->
  [a, b] = [1, 3]
  arrayEq [1, 2, 3], [a..b]
  arrayEq [1, 2], [a...b]
  b = -2
  arrayEq [1, 0, -1, -2], [a..b]
  arrayEq [1, 0, -1], [a...b]

test "ranges with expressions as endpoints", ->
  [a, b] = [1, 3]
  arrayEq [2, 3, 4, 5, 6], [(a + 1)..(2 * b)]
  arrayEq [2, 3, 4, 5], [(a + 1)...(2 * b)]

  arrayEq [2, 3, 4, 5], [(a + 1)...(2 * b)]

test "large ranges are generated with looping constructs", ->
  down = [99..0]
  eq 100, (len = down.length)
  eq 0, down[len - 1]

  up = [0...100]
  eq 100, (len = up.length)
  eq 99, up[len - 1]

test "for-from loops over ranges", ->
  array1 = []
  for x from [20..30]
    array1.push x
    break if x is 25
  arrayEq array1, [20, 21, 22, 23, 24, 25]

test "for-from comprehensions over ranges", ->
  array1 = (x + 10 for x from [20..25])
  ok array1.join(" ") is "30 31 32 33 34 35"

  array2 = (x for x from [20..30] when x %% 2 == 0)
  ok array2.join(" ") is "20 22 24 26 28 30"

test "#1012 slices with arguments object", ->
  expected = [0..9]
  argsAtStart = (-> [arguments[0]..9]) 0
  arrayEq expected, argsAtStart
  argsAtEnd = (-> [0..arguments[0]]) 9
  arrayEq expected, argsAtEnd
  argsAtBoth = (-> [arguments[0]..arguments[1]]) 0, 9
  arrayEq expected, argsAtBoth

test "#1409: creating large ranges outside of a function body", ->
  CoffeeScript.eval "[0..100]"

test "#2047: Infinite loop possible when \`for\` loop with \`range\` uses variables", ->
  up = 1
  down = -1
  a = 1
  b = 5

  testRange = (arg) ->
    [from, to, step, expectedResult] = arg
    r = (x for x in [from..to] by step)
    arrayEq r, expectedResult

  testData = [
    [1, 5, 1, [1..5]]
    [1, 5, -1, []]
    [1, 5, up, [1..5]]
    [1, 5, down, []]

    [a, 5, 1, [1..5]]
    [a, 5, -1, []]
    [a, 5, up, [1..5]]
    [a, 5, down, []]

    [1, b, 1, [1..5]]
    [1, b, -1, []]
    [1, b, up, [1..5]]
    [1, b, down, []]

    [a, b, 1, [1..5]]
    [a, b, -1, []]
    [a, b, up, [1..5]]
    [a, b, down, []]

    [5, 1, 1, []]
    [5, 1, -1, [5..1]]
    [5, 1, up, []]
    [5, 1, down, [5..1]]

    [5, a, 1, []]
    [5, a, -1, [5..1]]
    [5, a, up, []]
    [5, a, down, [5..1]]

    [b, 1, 1, []]
    [b, 1, -1, [5..1]]
    [b, 1, up, []]
    [b, 1, down, [5..1]]

    [b, a, 1, []]
    [b, a, -1, [5..1]]
    [b, a, up, []]
    [b, a, down, [5..1]]
  ]

  testRange d for d in testData

test "#2047: from, to and step as variables", ->
  up = 1
  down = -1
  a = 1
  b = 5

  r = (x for x in [a..b] by up)
  arrayEq r, [1..5]

  r = (x for x in [a..b] by down)
  arrayEq r, []

  r = (x for x in [b..a] by up)
  arrayEq r, []

  r = (x for x in [b..a] by down)
  arrayEq r, [5..1]

  a = 1
  b = -1
  step = 0
  r = (x for x in [b..a] by step)
  arrayEq r, []

test "#4884: Range not declaring var for the 'i'", ->
  "use strict"
  [0..21].forEach (idx) -> idx + 1

  eq global.i, undefined

test "#4889: \`for\` loop unexpected behavior", ->
  n = 1
  result = []
  for i in [0..n]
    result.push i
    for j in [(i + 1)..n]
      result.push j

  arrayEq result, [0, 1, 1, 2, 1]

test "#4889: \`for\` loop unexpected behavior with \`by 1\` on second loop", ->
  n = 1
  result = []
  for i in [0..n]
    result.push i
    for j in [(i + 1)..n] by 1
      result.push j

  arrayEq result, [0, 1, 1]

test "countdown example from docs", ->
  countdown = (num for num in [10..1])
  arrayEq countdown, [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]

test "counting up when the range goes down returns an empty array", ->
  countdown = (num for num in [10..1] by 1)
  arrayEq countdown, []

test "counting down when the range goes up returns an empty array", ->
  countup = (num for num in [1..10] by -1)
  arrayEq countup, []

test "counting down by too much returns just the first value", ->
  countdown = (num for num in [10..1] by -100)
  arrayEq countdown, [10]

test "counting up by too much returns just the first value", ->
  countup = (num for num in [1..10] by 100)
  arrayEq countup, [1]

`;

exports[`slicing_and_splicing.coffee 1`] = `
# Slicing and Splicing
# --------------------

# * Slicing
# * Splicing

# shared array
shared = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

# Slicing

test "basic slicing", ->
  arrayEq [7, 8, 9]   , shared[7..9]
  arrayEq [2, 3]      , shared[2...4]
  arrayEq [2, 3, 4, 5], shared[2...6]

test "slicing with variables as endpoints", ->
  [a, b] = [1, 4]
  arrayEq [1, 2, 3, 4], shared[a..b]
  arrayEq [1, 2, 3]   , shared[a...b]

test "slicing with expressions as endpoints", ->
  [a, b] = [1, 3]
  arrayEq [2, 3, 4, 5, 6], shared[(a+1)..2*b]
  arrayEq [2, 3, 4, 5]   , shared[a+1...(2*b)]

test "unbounded slicing", ->
  arrayEq [7, 8, 9]   , shared[7..]
  arrayEq [8, 9]      , shared[-2..]
  arrayEq [9]         , shared[-1...]
  arrayEq [0, 1, 2]   , shared[...3]
  arrayEq [0, 1, 2, 3], shared[..-7]

  arrayEq shared      , shared[..-1]
  arrayEq shared[0..8], shared[...-1]

  for a in [-shared.length..shared.length]
    arrayEq shared[a..] , shared[a...]
  for a in [-shared.length+1...shared.length]
    arrayEq shared[..a][...-1] , shared[...a]

  arrayEq [1, 2, 3], [1, 2, 3][..]

test "#930, #835, #831, #746 #624: inclusive slices to -1 should slice to end", ->
  arrayEq shared, shared[0..-1]
  arrayEq shared, shared[..-1]
  arrayEq shared.slice(1,shared.length), shared[1..-1]

test "string slicing", ->
  str = "abcdefghijklmnopqrstuvwxyz"
  ok str[1...1] is ""
  ok str[1..1] is "b"
  ok str[1...5] is "bcde"
  ok str[0..4] is "abcde"
  ok str[-5..] is "vwxyz"

test "#1722: operator precedence in unbounded slice compilation", ->
  list = [0..9]
  n = 2 # some truthy number in \`list\`
  arrayEq [0..n], list[..n]
  arrayEq [0..n], list[..n or 0]
  arrayEq [0..n], list[..if n then n else 0]

test "#2349: inclusive slicing to numeric strings", ->
  arrayEq [0, 1], [0..10][.."1"]

test "#4631: slicing with space before and/or after the dots", ->
  a = (s) -> s
  b = [4, 5, 6]
  c = [7, 8, 9]
  arrayEq [2, 3, 4], shared[2 ... 5]
  arrayEq [3, 4, 5], shared[3... 6]
  arrayEq [4, 5, 6], shared[4 ...7]
  arrayEq shared[(a b...)...(a c...)]  , shared[(a ...b)...(a ...c)]
  arrayEq shared[(a b...) ... (a c...)], shared[(a ...b) ... (a ...c)]
  arrayEq shared[(a b...)... (a c...)] , shared[(a ...b)... (a ...c)]
  arrayEq shared[(a b...) ...(a c...)] , shared[(a ...b) ...(a ...c)]


# Splicing

test "basic splicing", ->
  ary = [0..9]
  ary[5..9] = [0, 0, 0]
  arrayEq [0, 1, 2, 3, 4, 0, 0, 0], ary

  ary = [0..9]
  ary[2...8] = []
  arrayEq [0, 1, 8, 9], ary

test "unbounded splicing", ->
  ary = [0..9]
  ary[3..] = [9, 8, 7]
  arrayEq [0, 1, 2, 9, 8, 7]. ary

  ary[...3] = [7, 8, 9]
  arrayEq [7, 8, 9, 9, 8, 7], ary

  ary[..] = [1, 2, 3]
  arrayEq [1, 2, 3], ary

test "splicing with variables as endpoints", ->
  [a, b] = [1, 8]

  ary = [0..9]
  ary[a..b] = [2, 3]
  arrayEq [0, 2, 3, 9], ary

  ary = [0..9]
  ary[a...b] = [5]
  arrayEq [0, 5, 8, 9], ary

test "splicing with expressions as endpoints", ->
  [a, b] = [1, 3]

  ary = [0..9]
  ary[ a+1 .. 2*b+1 ] = [4]
  arrayEq [0, 1, 4, 8, 9], ary

  ary = [0..9]
  ary[a+1...2*b+1] = [4]
  arrayEq [0, 1, 4, 7, 8, 9], ary

test "splicing to the end, against a one-time function", ->
  ary = null
  fn = ->
    if ary
      throw 'err'
    else
      ary = [1, 2, 3]

  fn()[0..] = 1

  arrayEq ary, [1]

test "the return value of a splice literal should be the RHS", ->
  ary = [0, 0, 0]
  eq (ary[0..1] = 2), 2

  ary = [0, 0, 0]
  eq (ary[0..] = 3), 3

  arrayEq [ary[0..0] = 0], [0]

test "#1723: operator precedence in unbounded splice compilation", ->
  n = 4 # some truthy number in \`list\`

  list = [0..9]
  list[..n] = n
  arrayEq [n..9], list

  list = [0..9]
  list[..n or 0] = n
  arrayEq [n..9], list

  list = [0..9]
  list[..if n then n else 0] = n
  arrayEq [n..9], list

test "#2953: methods on endpoints in assignment from array splice literal", ->
  list = [0..9]

  Number.prototype.same = -> this
  list[1.same()...9.same()] = 5
  delete Number.prototype.same

  arrayEq [0, 5, 9], list

test "#1726: \`Op\` expression in property access causes unexpected results", ->
  a = [0..2]
  arrayEq a, a[(!1 in a)..]
  arrayEq a, a[!1 in a..]
  arrayEq a[(!1 in a)..], a[(!1 in a)..]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
shared = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

test "basic slicing", ->
  arrayEq [7, 8, 9], shared[7..9]
  arrayEq [2, 3], shared[2...4]
  arrayEq [2, 3, 4, 5], shared[2...6]

test "slicing with variables as endpoints", ->
  [a, b] = [1, 4]
  arrayEq [1, 2, 3, 4], shared[a..b]
  arrayEq [1, 2, 3], shared[a...b]

test "slicing with expressions as endpoints", ->
  [a, b] = [1, 3]
  arrayEq [2, 3, 4, 5, 6], shared[(a + 1)..(2 * b)]
  arrayEq [2, 3, 4, 5], shared[(a + 1)...(2 * b)]

test "unbounded slicing", ->
  arrayEq [7, 8, 9], shared[7..]
  arrayEq [8, 9], shared[-2..]
  arrayEq [9], shared[-1...]
  arrayEq [0, 1, 2], shared[...3]
  arrayEq [0, 1, 2, 3], shared[..-7]

  arrayEq shared, shared[..-1]
  arrayEq shared[0..8], shared[...-1]

  for a in [-shared.length..shared.length]
    arrayEq shared[a..], shared[a...]
  for a in [(-shared.length + 1)...shared.length]
    arrayEq shared[..a][...-1], shared[...a]

  arrayEq [1, 2, 3], [1, 2, 3][..]

test "#930, #835, #831, #746 #624: inclusive slices to -1 should slice to end", ->
  arrayEq shared, shared[0..-1]
  arrayEq shared, shared[..-1]
  arrayEq shared.slice(1, shared.length), shared[1..-1]

test "string slicing", ->
  str = "abcdefghijklmnopqrstuvwxyz"
  ok str[1...1] is ""
  ok str[1..1] is "b"
  ok str[1...5] is "bcde"
  ok str[0..4] is "abcde"
  ok str[-5..] is "vwxyz"

test "#1722: operator precedence in unbounded slice compilation", ->
  list = [0..9]
  n = 2
  arrayEq [0..n], list[..n]
  arrayEq [0..n], list[..(n or 0)]
  arrayEq [0..n], list[..(if n then n else 0)]

test "#2349: inclusive slicing to numeric strings", ->
  arrayEq [0, 1], [0..10][.."1"]

test "#4631: slicing with space before and/or after the dots", ->
  a = (s) -> s
  b = [4, 5, 6]
  c = [7, 8, 9]
  arrayEq [2, 3, 4], shared[2...5]
  arrayEq [3, 4, 5], shared[3...6]
  arrayEq [4, 5, 6], shared[4...7]
  arrayEq shared[(a b...)...(a c...)], shared[(a b...)...(a c...)]
  arrayEq shared[(a b...)...(a c...)], shared[(a b...)...(a c...)]
  arrayEq shared[(a b...)...(a c...)], shared[(a b...)...(a c...)]
  arrayEq shared[(a b...)...(a c...)], shared[(a b...)...(a c...)]

test "basic splicing", ->
  ary = [0..9]
  ary[5..9] = [0, 0, 0]
  arrayEq [0, 1, 2, 3, 4, 0, 0, 0], ary

  ary = [0..9]
  ary[2...8] = []
  arrayEq [0, 1, 8, 9], ary

test "unbounded splicing", ->
  ary = [0..9]
  ary[3..] = [9, 8, 7]
  arrayEq [0, 1, 2, 9, 8, 7].ary

  ary[...3] = [7, 8, 9]
  arrayEq [7, 8, 9, 9, 8, 7], ary

  ary[..] = [1, 2, 3]
  arrayEq [1, 2, 3], ary

test "splicing with variables as endpoints", ->
  [a, b] = [1, 8]

  ary = [0..9]
  ary[a..b] = [2, 3]
  arrayEq [0, 2, 3, 9], ary

  ary = [0..9]
  ary[a...b] = [5]
  arrayEq [0, 5, 8, 9], ary

test "splicing with expressions as endpoints", ->
  [a, b] = [1, 3]

  ary = [0..9]
  ary[(a + 1)..(2 * b + 1)] = [4]
  arrayEq [0, 1, 4, 8, 9], ary

  ary = [0..9]
  ary[(a + 1)...(2 * b + 1)] = [4]
  arrayEq [0, 1, 4, 7, 8, 9], ary

test "splicing to the end, against a one-time function", ->
  ary = null
  fn = ->
    if ary
      throw "err"
    else
      ary = [1, 2, 3]

  fn()[0..] = 1

  arrayEq ary, [1]

test "the return value of a splice literal should be the RHS", ->
  ary = [0, 0, 0]
  eq (ary[0..1] = 2), 2

  ary = [0, 0, 0]
  eq (ary[0..] = 3), 3

  arrayEq [(ary[0..0] = 0)], [0]

test "#1723: operator precedence in unbounded splice compilation", ->
  n = 4
  list = [0..9]
  list[..n] = n
  arrayEq [n..9], list

  list = [0..9]
  list[..(n or 0)] = n
  arrayEq [n..9], list

  list = [0..9]
  list[..(if n then n else 0)] = n
  arrayEq [n..9], list

test "#2953: methods on endpoints in assignment from array splice literal", ->
  list = [0..9]

  Number::same = -> @
  list[1.same()...9.same()] = 5
  delete Number::same

  arrayEq [0, 5, 9], list

test "#1726: \`Op\` expression in property access causes unexpected results", ->
  a = [0..2]
  arrayEq a, a[(!1 in a)..]
  arrayEq a, a[(!1 in a)..]
  arrayEq a[(!1 in a)..], a[(!1 in a)..]

`;

exports[`soaks.coffee 1`] = `
# Soaks
# -----

# * Soaked Property Access
# * Soaked Method Invocation
# * Soaked Function Invocation


# Soaked Property Access

test "soaked property access", ->
  nonce = {}
  obj = a: b: nonce
  eq nonce    , obj?.a.b
  eq nonce    , obj?['a'].b
  eq nonce    , obj.a?.b
  eq nonce    , obj?.a?['b']
  eq undefined, obj?.a?.non?.existent?.property

test "soaked property access caches method calls", ->
  nonce ={}
  obj = fn: -> a: nonce
  eq nonce    , obj.fn()?.a
  eq undefined, obj.fn()?.b

test "soaked property access caching", ->
  nonce = {}
  counter = 0
  fn = ->
    counter++
    'self'
  obj =
    self: -> @
    prop: nonce
  eq nonce, obj[fn()]()[fn()]()[fn()]()?.prop
  eq 3, counter

test "method calls on soaked methods", ->
  nonce = {}
  obj = null
  eq undefined, obj?.a().b()
  obj = a: -> b: -> nonce
  eq nonce    , obj?.a().b()

test "postfix existential operator mixes well with soaked property accesses", ->
  eq false, nonexistent?.property?

test "function invocation with soaked property access", ->
  id = (_) -> _
  eq undefined, id nonexistent?.method()

test "if-to-ternary should safely parenthesize soaked property accesses", ->
  ok (if nonexistent?.property then false else true)

test "#726: don't check for a property on a conditionally-referenced nonexistent thing", ->
  eq undefined, nonexistent?[Date()]

test "#756: conditional assignment edge cases", ->
  # TODO: improve this test
  a = null
  ok isNaN      a?.b.c +  1
  eq undefined, a?.b.c += 1
  eq undefined, ++a?.b.c
  eq undefined, delete a?.b.c

test "operations on soaked properties", ->
  # TODO: improve this test
  a = b: {c: 0}
  eq 1,   a?.b.c +  1
  eq 1,   a?.b.c += 1
  eq 2,   ++a?.b.c
  eq yes, delete a?.b.c


# Soaked Method Invocation

test "soaked method invocation", ->
  nonce = {}
  counter = 0
  obj =
    self: -> @
    increment: -> counter++; @
  eq obj      , obj.self?()
  eq undefined, obj.method?()
  eq nonce    , obj.self?().property = nonce
  eq undefined, obj.method?().property = nonce
  eq obj      , obj.increment().increment().self?()
  eq 2        , counter

test "#733: conditional assignments", ->
  a = b: {c: null}
  eq a.b?.c?(), undefined
  a.b?.c or= (it) -> it
  eq a.b?.c?(1), 1
  eq a.b?.c?([2, 3]...), 2


# Soaked Function Invocation

test "soaked function invocation", ->
  nonce = {}
  id = (_) -> _
  eq nonce    , id?(nonce)
  eq nonce    , (id? nonce)
  eq undefined, nonexistent?(nonce)
  eq undefined, (nonexistent? nonce)

test "soaked function invocation with generated functions", ->
  nonce = {}
  id = (_) -> _
  maybe = (fn, arg) -> if typeof fn is 'function' then () -> fn(arg)
  eq maybe(id, nonce)?(), nonce
  eq (maybe id, nonce)?(), nonce
  eq (maybe false, nonce)?(), undefined

test "soaked constructor invocation", ->
  eq 42       , +new Number? 42
  eq undefined,  new Other?  42

test "soaked constructor invocations with caching and property access", ->
  semaphore = 0
  nonce = {}
  class C
    constructor: ->
      ok false if semaphore
      semaphore++
    prop: nonce
  eq nonce, (new C())?.prop
  eq 1, semaphore

test "soaked function invocation safe on non-functions", ->
  eq undefined, (0)?(1)
  eq undefined, (0)? 1, 2
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
test "soaked property access", ->
  nonce = {}
  obj = a: b: nonce
  eq nonce, obj?.a.b
  eq nonce, obj?["a"].b
  eq nonce, obj.a?.b
  eq nonce, obj?.a?["b"]
  eq undefined, obj?.a?.non?.existent?.property

test "soaked property access caches method calls", ->
  nonce = {}
  obj = fn: -> a: nonce
  eq nonce, obj.fn()?.a
  eq undefined, obj.fn()?.b

test "soaked property access caching", ->
  nonce = {}
  counter = 0
  fn = ->
    counter++
    "self"
  obj = self: -> @, prop: nonce
  eq nonce, obj[fn()]()[fn()]()[fn()]()?.prop
  eq 3, counter

test "method calls on soaked methods", ->
  nonce = {}
  obj = null
  eq undefined, obj?.a().b()
  obj = a: -> b: -> nonce
  eq nonce, obj?.a().b()

test "postfix existential operator mixes well with soaked property accesses", ->
  eq false, nonexistent?.property?

test "function invocation with soaked property access", ->
  id = (_) -> _
  eq undefined, id nonexistent?.method()

test "if-to-ternary should safely parenthesize soaked property accesses", ->
  ok(
    if nonexistent?.property
      false
    else
      true
  )

test "#726: don't check for a property on a conditionally-referenced nonexistent thing", ->
  eq undefined, nonexistent?[Date()]

test "#756: conditional assignment edge cases", ->
  a = null
  ok isNaN a?.b.c + 1
  eq undefined, a?.b.c += 1
  eq undefined, ++a?.b.c
  eq undefined, delete a?.b.c

test "operations on soaked properties", ->
  a = b: c: 0
  eq 1, a?.b.c + 1
  eq 1, a?.b.c += 1
  eq 2, ++a?.b.c
  eq yes, delete a?.b.c

test "soaked method invocation", ->
  nonce = {}
  counter = 0
  obj =
    self: -> @
    increment: ->
      counter++
      @
  eq obj, obj.self?()
  eq undefined, obj.method?()
  eq nonce, (obj.self?().property = nonce)
  eq undefined, (obj.method?().property = nonce)
  eq(
    obj
    obj
      .increment()
      .increment()
      .self?()
  )
  eq 2, counter

test "#733: conditional assignments", ->
  a = b: c: null
  eq a.b?.c?(), undefined
  a.b?.c or= (it) -> it
  eq a.b?.c?(1), 1
  eq a.b?.c?([2, 3]...), 2

test "soaked function invocation", ->
  nonce = {}
  id = (_) -> _
  eq nonce, id? nonce
  eq nonce, id? nonce
  eq undefined, nonexistent? nonce
  eq undefined, nonexistent? nonce

test "soaked function invocation with generated functions", ->
  nonce = {}
  id = (_) -> _
  maybe = (fn, arg) ->
    if typeof fn is "function"
      -> fn arg
  eq maybe(id, nonce)?(), nonce
  eq maybe(id, nonce)?(), nonce
  eq maybe(false, nonce)?(), undefined

test "soaked constructor invocation", ->
  eq 42, +new Number?(42)
  eq undefined, new Other? 42

test "soaked constructor invocations with caching and property access", ->
  semaphore = 0
  nonce = {}
  class C
    constructor: ->
      ok false if semaphore
      semaphore++
    prop: nonce
  eq nonce, new C()?.prop
  eq 1, semaphore

test "soaked function invocation safe on non-functions", ->
  eq undefined, (0)? 1
  eq undefined, (0)? 1, 2

`;
